{"version":3,"sources":["../node_modules/science-halt/index.js","../src/v2.ts","../src/accelerate.ts","../src/collide-circle-circle.ts","../src/collide-circle-edge.ts","../src/collision-response-aabb.ts","../src/solve-distance-constraint.ts","../src/solve-drag.ts","../src/solve-gravitation.ts","../src/inertia.ts","../src/overlap-aabb-aabb.ts","../src/overlap-circle-circle.ts","../src/segment-intersection.ts","../src/rewind-to-collision-point.ts","../src/project-point-edge.ts","../src/project-capsule.ts","../src/index.ts","aabb-overlap.ts","aabb-soup.ts","circle-collisions.ts","circle-box-collision.ts","edge-collision.ts","platformer.ts","bucket.ts","edge-collision-aabb.ts","index.ts"],"names":[],"mappings":"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","file":"examples.368de6b3.js","sourceRoot":"../examples","sourcesContent":["\nmodule.exports = function(onhalt, opt_msg, opt_keycode) {\n  document.addEventListener('keydown', function(e) {\n    if (e.which == (opt_keycode || 27)) {\n      onhalt();\n      console.log(opt_msg || 'HALT IN THE NAME OF SCIENCE!');\n    }\n  })\n}","export type Vector2<V extends number = number> = { x: V; y: V; };\n\nexport function v2<V extends number> (x?: V, y?: V): Vector2<V> {\n  return { x: x || 0 as V, y: y || 0 as V}\n}\n\nexport const copy = (out: Vector2, a: Vector2) => {\n  out.x = a.x;\n  out.y = a.y;\n  return out;\n}\n\nexport const set = <V extends number>(out: Vector2<V>, x: V, y: V) => {\n  out.x = x;\n  out.y = y;\n  return out;\n}\n\nexport const add = <V extends number>(out: Vector2<V>, a: Vector2<V>, b: Vector2<V>) => {\n  out.x = a.x + b.x as V;\n  out.y = a.y + b.y as V;\n  return out;\n}\n\nexport const sub = <V extends number>(out: Vector2<V>, a: Vector2<V>, b: Vector2<V>) => {\n  out.x = a.x - b.x as V;\n  out.y = a.y - b.y as V;\n  return out;\n}\n\nexport const dot = <V extends number>(a: Vector2<V>, b: Vector2<V>) => a.x * b.x + a.y * b.y\n\nexport const scale = <V extends number>(out: Vector2<V>, a: Vector2<V>, factor: number) => {\n  out.x = a.x * factor as V;\n  out.y = a.y * factor as V;\n  return out;\n}\n\nexport const distance = <V extends number>(v1: Vector2<V>, v2: Vector2<V>) => {\n  const x = v1.x - v2.x;\n  const y = v1.y - v2.y;\n  return Math.sqrt(x*x + y*y);\n}\n\nexport const distance2 = <V extends number>(v1: Vector2<V>, v2: Vector2<V>) => {\n  const x = v1.x - v2.x;\n  const y = v1.y - v2.y;\n  return x*x + y*y;\n}\n\nexport const magnitude = <V extends number>(v1: Vector2<V>) => {\n  const x = v1.x;\n  const y = v1.y;\n  return Math.sqrt(x*x + y*y);\n}\n\nexport const normalize = <V extends number>(out: Vector2<V>, a: Vector2<V>) => {\n  const x = a.x;\n  const y = a.y;\n  let len = x*x + y*y;\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    out.x = a.x * len as V;\n    out.y = a.y * len as V;\n  }\n  return out;\n}\n\n/**\n * Compute the normal pointing away perpendicular from two vectors.\n * Given v1(0,0) -> v2(10, 0), the normal will be (0, 1)\n * */\nexport const normal = <V extends number>(out: Vector2<V>, v1: Vector2<V>, v2: Vector2<V>) => {\n  out.y = v2.x - v1.x as V;\n  out.x = v1.y - v2.y as V;\n  return normalize(out, out);\n}\n\n// the perpendicular dot product, also known as \"cross\" elsewhere\n// http://stackoverflow.com/a/243977/169491\nexport const perpDot = <V extends number>(v1: Vector2<V>, v2: Vector2<V>) => {\n  return v1.x * v2.y - v1.y * v2.x;\n}\n\n/**\n * This is mostly useful for moving a verlet-style [current, previous]\n * by the same amount, translating them while preserving velocity.\n * @param by the vector to add to each subsequent vector\n * @param vN any number of vectors to translate\n */\nexport const translate = <V extends number>(by: Vector2<V>, ...vN: Vector2<V>[]) => {\n  for (let i = 0; i < vN.length; i++) {\n    const v = vN[i];\n    add(v, v, by);\n  }\n}\n\n/**\n * \n * @param v Print this vector for nice logs\n */\nexport function vd(v: Vector2) {\n  return `(${v.x}, ${v.y})`;\n}\n\n/**\n * Rotate a vector around another point. Taken nearly verbatim from gl-matrix\n */\nexport const rotate2d = <V extends Vector2>(\n  out: V,\n  target: V,\n  origin: V,\n  rad: number\n) => {\n  //Translate point to the origin\n  const p0 = target.x - origin.x;\n  const p1 = target.y - origin.y;\n  const sinC = Math.sin(rad);\n  const cosC = Math.cos(rad);\n\n  //perform rotation and translate to correct position\n  out.x = p0 * cosC - p1 * sinC + origin.x;\n  out.y = p0 * sinC + p1 * cosC + origin.y;\n\n  return out;\n}\n\n/**\n * Compute the Theta angle between a vector and the origin.\n */\nexport function angleOf(v: Vector2) {\n  return Math.atan2(v.y, v.x);\n}","import { set } from './v2';\nimport { DeltaTimeMS, Integratable } from './common-types';\n\nexport const accelerate = (cmp: Integratable, dt: DeltaTimeMS) => {\n  // apply acceleration to current position, convert dt to seconds\n  cmp.cpos.x += cmp.acel.x * dt * dt * 0.001;\n  cmp.cpos.y += cmp.acel.y * dt * dt * 0.001;\n\n  // reset acceleration\n  set(cmp.acel, 0, 0);\n};","import { add, distance2, set, sub } from \"./v2\";\nimport { VelocityDerivable } from \"./common-types\";\n\n// Preallocations!\nconst vel1 = { x: 0, y: 0 };\nconst vel2 = { x: 0, y: 0 };\nconst diff = { x: 0, y: 0 };\nconst move = { x: 0, y: 0 };\n\n// TODO: is the below even true???\n// The codeflow demo does nothing if the circles are no longer overlapping.\n\n// It's very important that this function not do any distance checking.\n// It is assumed that if this function is called, then the points are\n// definitely colliding, and that after being called with preserveInertia\n// === false, another call with === true should be made, even if the first\n// calculation has moved the points away from physically touching.\n\nexport const collideCircleCircle = (\n  p1: VelocityDerivable,\n  p1radius: number,\n  p1mass: number,\n  p2: VelocityDerivable,\n  p2radius: number,\n  p2mass: number,\n  preserveInertia: boolean,\n  damping: number\n) => {\n  const dist2 = distance2(p1.cpos, p2.cpos);\n  const target = p1radius + p2radius;\n  const min2 = target * target;\n\n  // if (dist2 > min2) return;\n\n  sub(vel1, p1.cpos, p1.ppos);\n  sub(vel2, p2.cpos, p2.ppos);\n\n  sub(diff, p1.cpos, p2.cpos);\n  const dist = Math.sqrt(dist2);\n  let factor = (dist - target) / dist;\n\n  // Avoid division by zero in case points are directly atop each other.\n  if (dist === 0) factor = 1;\n\n  const mass1 = p1mass > 0 ? p1mass : 1;\n  const mass2 = p2mass > 0 ? p2mass : 1;\n  const massT = mass1 + mass2;\n\n  // Move a away\n  move.x = diff.x * factor * (mass2 / massT);\n  move.y = diff.y * factor * (mass2 / massT);\n  if (p1mass > 0) {\n    sub(p1.cpos, p1.cpos, move);\n  }\n\n  // Move b away\n  move.x = diff.x * factor * (mass1 / massT);\n  move.y = diff.y * factor * (mass1 / massT);\n  if (p2mass > 0) {\n    add(p2.cpos, p2.cpos, move);\n  }\n\n  if (!preserveInertia) return;\n\n  damping = damping || 1;\n\n  const f1 = (damping * (diff.x * vel1.x + diff.y * vel1.y)) / (dist2 || 1);\n  const f2 = (damping * (diff.x * vel2.x + diff.y * vel2.y)) / (dist2 || 1);\n\n  vel1.x += (f2 * diff.x - f1 * diff.x) / (mass1 || 1); // * (mass2 / massT);\n  vel2.x += (f1 * diff.x - f2 * diff.x) / (mass2 || 1); // * (mass1 / massT);\n  vel1.y += (f2 * diff.y - f1 * diff.y) / (mass1 || 1); // * (mass2 / massT);\n  vel2.y += (f1 * diff.y - f2 * diff.y) / (mass2 || 1); // * (mass1 / massT);\n\n  if (p1mass > 0) set(p1.ppos, p1.cpos.x - vel1.x, p1.cpos.y - vel1.y);\n  if (p2mass > 0) set(p2.ppos, p2.cpos.x - vel2.x, p2.cpos.y - vel2.y);\n};\n","import {\n  add,\n  distance2,\n  set,\n  sub,\n  v2,\n  dot,\n  scale,\n  distance,\n  copy,\n  normalize,\n  Vector2\n} from \"./v2\";\nimport { collideCircleCircle } from \"./collide-circle-circle\";\nimport { VelocityDerivable } from \"./common-types\";\n\n// Preallocations\nconst edgeDir = v2();\nconst edge = v2();\nconst prevEdge = v2();\nconst hypo = v2();\nconst epDiff = v2();\nconst correction = v2();\nconst collisionPoint = v2();\nconst tunnelPoint = v2();\n\nconst ep = {\n  cpos: v2(),\n  ppos: v2()\n};\n\nconst epBefore = {\n  cpos: v2(),\n  ppos: v2()\n};\n\nexport function collideCircleEdge(\n  circle: VelocityDerivable,\n  radius3: number,\n  mass3: number,\n  endpoint1: VelocityDerivable,\n  mass1: number,\n  endpoint2: VelocityDerivable,\n  mass2: number,\n  preserveInertia: boolean,\n  damping: number\n) {\n  // Edge direction (edge in local space)\n  sub(edge, endpoint2.cpos, endpoint1.cpos);\n\n  // Normalize collision edge (assume collision axis is edge)\n  normalize(edgeDir, edge);\n\n  // Vector from endpoint1 to particle\n  sub(hypo, circle.cpos, endpoint1.cpos);\n\n  // Where is the particle on the edge, before, after, or on?\n  // Also used for interpolation later.\n  const projection = dot(edge, hypo);\n  const maxDot = dot(edge, edge);\n  const edgeMag = Math.sqrt(maxDot);\n\n  // Colliding beyond the edge...\n  if (projection < 0 || projection > maxDot) return;\n\n  // Create interpolation factor of where point closest\n  // to particle is on the line.\n  const t = projection / maxDot;\n  const u = 1 - t;\n\n  // Find the point of collision on the edge.\n  scale(collisionPoint, edgeDir, t * edgeMag);\n  add(collisionPoint, collisionPoint, endpoint1.cpos);\n  const dist = distance(collisionPoint, circle.cpos);\n\n  // Bail if point and edge are too far apart.\n  if (dist > radius3) return;\n\n  // Distribute mass of colliding point into two fake points\n  // and use those to collide against each endpoint independently.\n\n  const standinMass1 = u * mass3;\n  const standinMass2 = t * mass3;\n\n  const standin1 = {\n    cpos: v2(),\n    ppos: v2()\n  };\n\n  const standin2 = {\n    cpos: v2(),\n    ppos: v2()\n  };\n\n  // Slide standin1 along edge to be in front of endpoint1\n  scale(standin1.cpos, edgeDir, t * edgeMag);\n  sub(standin1.cpos, circle.cpos, standin1.cpos);\n  scale(standin1.ppos, edgeDir, t * edgeMag);\n  sub(standin1.ppos, circle.ppos, standin1.ppos);\n\n  // Slide standin2 along edge to be in front of endpoint2\n  scale(standin2.cpos, edgeDir, u * edgeMag);\n  add(standin2.cpos, circle.cpos, standin2.cpos);\n  scale(standin2.ppos, edgeDir, u * edgeMag);\n  add(standin2.ppos, circle.ppos, standin2.ppos);\n\n  const standin1Before = {\n    cpos: v2(),\n    ppos: v2()\n  };\n\n  const standin2Before = {\n    cpos: v2(),\n    ppos: v2()\n  };\n\n  // Stash state of standins\n  copy(standin1Before.cpos, standin1.cpos);\n  copy(standin1Before.ppos, standin1.ppos);\n  copy(standin2Before.cpos, standin2.cpos);\n  copy(standin2Before.ppos, standin2.ppos);\n\n  const edgeRadius = 0;\n\n  // Collide standins with endpoints\n  collideCircleCircle(\n    standin1,\n    radius3,\n    standinMass1,\n    endpoint1,\n    edgeRadius,\n    mass1,\n    preserveInertia,\n    damping\n  );\n\n  collideCircleCircle(\n    standin2,\n    radius3,\n    standinMass2,\n    endpoint2,\n    edgeRadius,\n    mass2,\n    preserveInertia,\n    damping\n  );\n\n  const standin1Delta = {\n    cpos: v2(),\n    ppos: v2()\n  };\n\n  const standin2Delta = {\n    cpos: v2(),\n    ppos: v2()\n  };\n\n  // Compute standin1 cpos change\n  sub(standin1Delta.cpos, standin1.cpos, standin1Before.cpos);\n\n  // Compute standin2 cpos change\n  sub(standin2Delta.cpos, standin2.cpos, standin2Before.cpos);\n\n  scale(standin1Delta.cpos, standin1Delta.cpos, u);\n  scale(standin2Delta.cpos, standin2Delta.cpos, t);\n\n  // Apply cpos changes to point3\n  add(circle.cpos, circle.cpos, standin1Delta.cpos);\n  add(circle.cpos, circle.cpos, standin2Delta.cpos);\n\n  if (!preserveInertia) return;\n\n  // TODO: instead of adding diff, get magnitude of diff and scale\n  // in reverse direction of standin velocity from point3.cpos because\n  // that is what circlecircle does.\n\n  // Compute standin1 ppos change\n  sub(standin1Delta.ppos, standin1.ppos, standin1Before.ppos);\n\n  // Compute standin2 ppos change\n  sub(standin2Delta.ppos, standin2.ppos, standin2Before.ppos);\n\n  scale(standin1Delta.ppos, standin1Delta.ppos, u);\n  scale(standin2Delta.ppos, standin2Delta.ppos, t);\n\n  // Apply ppos changes to point3\n  add(circle.ppos, circle.ppos, standin1Delta.ppos);\n  add(circle.ppos, circle.ppos, standin2Delta.ppos);\n}\n\ntype Particle = {\n  mass: number;\n  radius: number;\n} & VelocityDerivable;\n\nfunction snapshotDebug(\n  name: string,\n  particles: Particle[] = [],\n  points: [string, Vector2][] = []\n) {\n  const cvs = document.createElement(\"canvas\");\n  const ctx = cvs.getContext(\"2d\")!;\n  document.body.appendChild(cvs);\n  // let minX = Number.MAX_SAFE_INTEGER;\n  // let maxX = Number.MIN_SAFE_INTEGER;\n  // let minY = Number.MAX_SAFE_INTEGER;\n  // let maxY = Number.MIN_SAFE_INTEGER;\n  // for (let i = 0; i < particles.length; i++) {\n  //   const particle = particles[i];\n  //   minX = Math.min(\n  //     minX,\n  //     particle.cpos.x - particle.radius,\n  //     particle.ppos.x - particle.radius\n  //   );\n  //   maxX = Math.max(\n  //     maxX,\n  //     particle.cpos.x + particle.radius,\n  //     particle.ppos.x + particle.radius\n  //   );\n  //   minY = Math.min(\n  //     minY,\n  //     particle.cpos.y - particle.radius,\n  //     particle.ppos.y - particle.radius\n  //   );\n  //   maxY = Math.max(\n  //     maxY,\n  //     particle.cpos.y + particle.radius,\n  //     particle.ppos.y + particle.radius\n  //   );\n  // }\n\n  // for (let i = 0; i < points.length; i++) {\n  //   const [, point] = points[i];\n  //   minX = Math.min(minX, point.x, point.x);\n  //   maxX = Math.max(maxX, point.x, point.x);\n  //   minY = Math.min(minY, point.y, point.y);\n  //   maxY = Math.max(maxY, point.y, point.y);\n  // }\n\n  // cvs.width = maxX - minX;\n  // cvs.height = maxY - minY;\n\n  // ctx.translate(-minX, -minY);\n\n  cvs.width = 800;\n  cvs.height = 800;\n\n  for (let i = 0; i < particles.length; i++) {\n    const particle = particles[i];\n    ctx.fillStyle = \"rgba(255, 0, 0, 0.5)\";\n    ctx.beginPath();\n    ctx.arc(\n      particle.ppos.x,\n      particle.ppos.y,\n      particle.radius,\n      0,\n      Math.PI * 2,\n      false\n    );\n    ctx.fill();\n\n    ctx.fillStyle = \"rgba(0, 0, 0, 0.5)\";\n    ctx.beginPath();\n    ctx.arc(\n      particle.cpos.x,\n      particle.cpos.y,\n      particle.radius,\n      0,\n      Math.PI * 2,\n      false\n    );\n    ctx.fill();\n  }\n\n  for (let i = 0; i < points.length; i++) {\n    const [name, point] = points[i];\n    ctx.fillStyle = \"purple\";\n    ctx.fillRect(point.x, point.y, 1, 1);\n    ctx.fillText(`${name} (${point.x},${point.y})`, point.x + 1, point.y + 1);\n  }\n\n  // ctx.translate(minX, minY);\n  ctx.fillStyle = \"black\";\n  ctx.fillText(name, 10, 10);\n}\n","import {\n  add,\n  dot,\n  magnitude,\n  normalize,\n  scale,\n  set,\n  copy,\n  sub,\n  v2,\n  Vector2\n} from \"./v2\";\n\n// Registers / Preallocations\n\nconst basis = v2();\nconst basisNeg = v2();\n\nconst vel1 = v2();\nconst vel1x = v2();\nconst vel1y = v2();\n\nconst vel2 = v2();\nconst vel2x = v2();\nconst vel2y = v2();\n\nconst newVel1 = v2();\nconst newVel2 = v2();\n\nconst t1 = v2();\nconst t2 = v2();\n\nconst u1 = v2();\nconst u2 = v2();\n\n// TODO: Put this somewhere...\nconst EPSILON = 0.0001;\n\n// TODO: change this API to accept numbers (x, y) instead of vectors\n\n// friction calc: sqrt(friction1*friction2)\n// restitution: box2d: https://github.com/erincatto/Box2D/blob/6a69ddbbd59b21c0d6699c43143b4114f7f92e21/Box2D/Box2D/Dynamics/Contacts/b2Contact.h#L42-L47\n// Math.max(restitution1, restitution2);\n\n/**\n * Really should be called collisionResponseImpulse, as it has nothing to do\n * with the shape of the bodies colliding. It's just two points with mass and\n * friction.\n * @param cpos1 \n * @param ppos1 \n * @param mass1 \n * @param restitution1 1 == perfectly elastic collision, 0 == all energy is\n * killed.\n * @param staticFriction1 How much friction must be overcome before the object\n * will start moving. 0 == no friction, 1 == max friction. Set this higher, like\n * 0.9.\n * @param dynamicFriction1 How much constant friction occurs when the object is\n * already in motion. 0 == no friction, 1 == max friction. Better to set this\n * low, like 0.1.\n * @param cpos2 \n * @param ppos2 \n * @param mass2 \n * @param restitution2 1 == perfectly elastic collision, 0 == all energy is\n * killed.\n * @param staticFriction2 How much friction must be overcome before the object\n * will start moving. 0 == no friction, 1 == max friction. Set this higher, like\n * 0.9.\n * @param dynamicFriction2 How much constant friction occurs when the object is\n * already in motion. 0 == no friction, 1 == max friction. Better to set this\n * low, like 0.1.\n * @param collisionNormal The vector defining the relative axis of collision.\n * Leaving this as 0,0 will compute it as the midpoint between positions of the\n * two colliding objects (modeling a circular collision). If colliding with a\n * known edge or line segment, it's best to provide the edge normal as this\n * value.\n * @param vel1out The new velocity resulting from reacting to this collison.\n * cpos1 - this value == new ppos1.\n * @param vel2out The new velocity resulting from reacting to this collison.\n * cpos2 - this value == new ppos2.\n */\nexport const collisionResponseAABB = (\n  cpos1: Vector2,\n  ppos1: Vector2,\n  mass1: number,\n  restitution1: number,\n  staticFriction1: number,\n  dynamicFriction1: number,\n  cpos2: Vector2,\n  ppos2: Vector2,\n  mass2: number,\n  restitution2: number,\n  staticFriction2: number,\n  dynamicFriction2: number,\n  collisionNormal: Vector2,\n  vel1out: Vector2,\n  vel2out: Vector2\n) => {\n  // blank out all preallocated vectors.\n  set(basis, 0, 0);\n  set(basisNeg, 0, 0);\n  set(vel1, 0, 0);\n  set(vel1x, 0, 0);\n  set(vel1y, 0, 0);\n  set(vel2, 0, 0);\n  set(vel2x, 0, 0);\n  set(vel2y, 0, 0);\n  set(newVel1, 0, 0);\n  set(newVel2, 0, 0);\n  set(t1, 0, 0);\n  set(t2, 0, 0);\n  set(u1, 0, 0);\n  set(u2, 0, 0);\n\n  // If collisionNormal is provided, use it. Otherwise, use midpoint between\n  // current positions as axis of collision. Midpoint will model a circular\n  // collision if used.\n  if (collisionNormal && (collisionNormal.x !== 0 || collisionNormal.y !== 0)) {\n    set(basis, collisionNormal.x, collisionNormal.y);\n  } else {\n    sub(basis, cpos1, cpos2);\n    normalize(basis, basis);\n  }\n\n  scale(basisNeg, basis, -1);\n\n  //const friction;\n  // Take max of restitutions, like box2d does.\n  // https://github.com/erincatto/Box2D/blob/6a69ddbbd59b21c0d6699c43143b4114f7f92e21/Box2D/Box2D/Dynamics/Contacts/b2Contact.h#L42-L47\n  // \"for example, a superball bounces on everything\"\n  const restitution = restitution1 > restitution2 ? restitution1 : restitution2;\n  const massTotal = mass1 + mass2;\n  const e = 1 + restitution;\n\n  // I = (1+e)*N*(Vr  N) / (1/Ma + 1/Mb)\n  // Va -= I * 1/Ma\n  // Vb += I * 1/Mb\n  //sub(vel1, cpos1, ppos1);\n  //sub(vel2, cpos2, ppos2);\n  //const relativeVelocity = sub(vel1, vel2);\n  //const I = v2();\n  //scale(I, normal, (1 + restitution) * dot(relativeVelocity, normal));\n  //scale(I, I, 1 / (1/mass1 + 1/mass2));\n\n  // \"x\" and \"y\" in the following sections are shorthand for:\n  // x: component of the box velocity parallel to the collision normal\n  // y: the rest of the collision velocity\n\n  // calculate x-direction velocity vector and perpendicular y-vector for box 1\n  sub(vel1, cpos1, ppos1);\n  const x1 = dot(basis, vel1);\n  scale(vel1x, basis, x1);\n  sub(vel1y, vel1, vel1x);\n\n  // calculate x-direction velocity vector and perpendicular y-vector for box 2\n  sub(vel2, cpos2, ppos2);\n  const x2 = dot(basisNeg, vel2);\n  scale(vel2x, basisNeg, x2);\n  sub(vel2y, vel2, vel2x);\n\n  // equations of motion for box1\n  scale(t1, vel1x, (mass1 - mass2) / massTotal);\n  scale(t2, vel2x, (e * mass2) / massTotal);\n  add(newVel1, t1, t2);\n  add(newVel1, newVel1, vel1y);\n\n  // equations of motion for box2\n  scale(u1, vel1x, (e * mass1) / massTotal);\n  scale(u2, vel2x, (mass2 - mass1) / massTotal);\n  add(newVel2, u1, u2);\n  add(newVel2, newVel2, vel2y);\n\n  // new relative velocity\n  const rv = add(v2(), newVel1, newVel2);\n\n  // tangent to relative velocity vector\n  const reg1 = v2();\n  scale(reg1, basis, dot(rv, basis));\n  const tangent = sub(v2(), rv, reg1);\n  normalize(tangent, tangent);\n\n  // magnitude of relative velocity in tangent direction\n  let jt = -dot(rv, tangent);\n  jt /= 1 / (mass1 + mass2); // not sure about this...\n  // https://github.com/RandyGaul/ImpulseEngine/blob/d12af9c95555244a37dce1c7a73e60d5177df652/Manifold.cpp#L103\n\n  const jtMag = Math.abs(jt);\n\n  // only apply significant friction\n  if (jtMag > EPSILON) {\n    // magnitudes of velocity along the collision tangent, hopefully.\n    const vel1ymag = magnitude(vel1y);\n    const vel2ymag = magnitude(vel2y);\n\n    // compute Coulumb's law (choosing dynamic vs static friction)\n    const frictionImpulse1 = v2();\n    const frictionImpulse2 = v2();\n\n    // TODO: may need to use Math.max(Math.abs(vel1ymag, vel2ymag)) when\n    // choosing to incorporate velocity magnitude into the friction calc.\n    // A stationary box getting hit currently receives perfect energy\n    // transfer, since its vel2ymag is 0.\n\n    if (jtMag < vel1ymag * staticFriction1) {\n      scale(frictionImpulse1, tangent, staticFriction1);\n    } else {\n      scale(frictionImpulse1, tangent, -vel1ymag * dynamicFriction1);\n    }\n\n    if (jtMag < vel2ymag * staticFriction2) {\n      scale(frictionImpulse2, tangent, staticFriction2);\n    } else {\n      scale(frictionImpulse2, tangent, -vel2ymag * dynamicFriction2);\n    }\n\n    add(newVel1, newVel1, frictionImpulse1);\n    add(newVel2, newVel2, frictionImpulse2);\n  }\n\n  // output new velocity of box1 and box2\n  copy(vel1out, newVel1);\n  copy(vel2out, newVel2);\n};\n","import { add, distance2, set, sub, v2, magnitude, scale } from \"./v2\";\nimport { Integratable } from \"./common-types\";\n\n// negative or zero mass implies a fixed or \"pinned\" point\nexport function solveDistanceConstraint(\n  p1: Integratable,\n  p1mass: number,\n  p2: Integratable,\n  p2mass: number,\n  goal: number,\n  // number between 0 and 1\n  stiffness: number = 1\n) {\n  const mass1 = p1mass > 0 ? p1mass : 1;\n  const mass2 = p2mass > 0 ? p2mass : 1;\n  const imass1 = 1 / (mass1 || 1);\n  const imass2 = 1 / (mass2 || 1);\n  const imass = imass1 + imass2;\n\n  // Current relative vector\n  const delta = sub(v2(), p2.cpos, p1.cpos);\n  const deltaMag = magnitude(delta);\n\n  // nothing to do.\n  if (deltaMag === 0) return;\n\n  // Difference between current distance and goal distance\n  const diff = (deltaMag - goal) / deltaMag;\n\n  // TODO: is this even correct? Should mass come into effect here?\n  // approximate mass\n  scale(delta, delta, diff / imass);\n\n  // TODO: not sure if this is the right place to apply stiffness.\n  const p1correction = scale(v2(), delta, imass1 * stiffness);\n  const p2correction = scale(v2(), delta, imass2 * stiffness);\n\n  // Add correction to p1, but only if not \"pinned\".\n  // If it's pinned and p2 is not, apply it to p2.\n  if (p1mass > 0) {\n    add(p1.cpos, p1.cpos, p1correction);\n  } else if (p2mass > 0) {\n    sub(p2.cpos, p2.cpos, p1correction);\n  }\n\n  // Add correction to p2, but only if not \"pinned\".\n  // If it's pinned and p1 is not, apply it to p1.\n  if (p2mass > 0) {\n    sub(p2.cpos, p2.cpos, p2correction);\n  } else if (p1mass > 0) {\n    add(p1.cpos, p1.cpos, p2correction);\n  }\n}\n","import { VelocityDerivable } from \"./common-types\";\n\nexport const solveDrag = (p1: VelocityDerivable, drag: number) => {\n  const x = (p1.ppos.x - p1.cpos.x) * drag;\n  const y = (p1.ppos.y - p1.cpos.y) * drag;\n  p1.ppos.x = p1.cpos.x + x;\n  p1.ppos.y = p1.cpos.y + y;\n};","import { add, magnitude, normalize, scale, set, v2 } from \"./v2\";\nimport { Integratable, VelocityDerivable } from \"./common-types\";\nconst accel1 = v2();\n\nexport function solveGravitation(\n  p1: Integratable,\n  p1mass: number,\n  p2: VelocityDerivable,\n  p2mass: number,\n  gravityConstant = 0.99\n) {\n  // handle either obj not having mass\n  if (p1mass <= 0 || p2mass <= 0) return;\n\n  let mag: number;\n  let factor: number;\n\n  const diffx = p2.cpos.x - p1.cpos.x;\n  const diffy = p2.cpos.y - p1.cpos.y;\n\n  set(accel1, diffx, diffy);\n  mag = magnitude(accel1);\n\n  // Prevent divide by zero.\n  mag = mag === 0 ? 1 : mag;\n\n  // Newton's Law of Universal Gravitation -- Vector Form!\n  factor = gravityConstant * ((p1mass * p2mass) / (mag * mag));\n\n  // scale by gravity acceleration\n  normalize(accel1, accel1);\n  scale(accel1, accel1, factor);\n\n  // add the acceleration from gravity to p1 accel\n  add(p1.acel, p1.acel, accel1);\n}\n","import { set } from \"./v2\";\nimport { Integratable } from \"./common-types\";\n\nexport const inertia = (cmp: Integratable) => {\n  const x = cmp.cpos.x * 2 - cmp.ppos.x;\n  const y = cmp.cpos.y * 2 - cmp.ppos.y;\n\n  set(cmp.ppos, cmp.cpos.x, cmp.cpos.y);\n  set(cmp.cpos, x, y);\n};\n","import { set, Vector2, normalize, v2 } from \"./v2\";\n\n// https://github.com/noonat/intersect/blob/master/intersect.js\n\nexport type AABBOverlapResult = {\n  resolve: Vector2;\n  hitPos: Vector2;\n  normal: Vector2;\n};\n\n/**\n * Create a result object to use for overlap tests.\n */\nexport const createAABBOverlapResult = () => {\n  return { resolve: v2(), hitPos: v2(), normal: v2() };\n};\n\n/**\n * Compute the \"collision manifold\" for two AABB, storing the result in `result`.\n * Note: The `normal` is always perpendicular to an AABB edge, which may produce\n * some slighly weird-looking collisions. `collisionResponseAABB()` will compute\n * a normal using the midpoints, which looks more natural.\n */\nexport const overlapAABBAABB = (\n  center1X: number,\n  center1Y: number,\n  width1: number,\n  height1: number,\n  center2X: number,\n  center2Y: number,\n  width2: number,\n  height2: number,\n  result: AABBOverlapResult\n) => {\n  const dx = center2X - center1X;\n  const px = width2 / 2 + width1 / 2 - Math.abs(dx);\n  const dy = center2Y - center1Y;\n  const py = height2 / 2 + height1 / 2 - Math.abs(dy);\n\n  if (px <= 0) return null;\n  if (py <= 0) return null;\n\n  set(result.resolve, 0, 0);\n  set(result.hitPos, 0, 0);\n  set(result.normal, 0, 0);\n\n  if (px < py) {\n    const sx = dx < 0 ? -1 : 1;\n    result.resolve.x = px * sx;\n    result.normal.x = sx;\n    // Really not sure about these values.\n    result.hitPos.x = center1X + (width1 / 2) * sx;\n    result.hitPos.y = center2Y;\n  } else {\n    const sy = dy < 0 ? -1 : 1;\n    result.resolve.y = py * sy;\n    result.normal.y = sy;\n    // Really not sure about these values.\n    result.hitPos.x = center2X;\n    result.hitPos.y = center1Y + (height1 / 2) * sy;\n  }\n\n  return result;\n};\n","export const overlapCircleCircle = (\n  ax: number,\n  ay: number,\n  arad: number,\n  bx: number,\n  by: number,\n  brad: number\n) => {\n  const x = bx - ax;\n  const y = by - ay;\n  const rad = arad + brad;\n  return x * x + y * y < rad * rad;\n};\n","import { sub, v2, Vector2 } from \"./v2\";\n\nconst s1 = v2();\nconst s2 = v2();\n\nexport function segmentIntersection(\n  p0: Vector2,\n  p1: Vector2,\n  p2: Vector2,\n  p3: Vector2,\n  intersectionPoint: Vector2\n) {\n  sub(s1, p1, p0);\n  sub(s2, p3, p2);\n\n  const s =\n    (-s1.y * (p0.x - p2.x) + s1.x * (p0.y - p2.y)) /\n    (-s2.x * s1.y + s1.x * s2.y);\n  const t =\n    (s2.x * (p0.y - p2.y) - s2.y * (p0.x - p2.x)) /\n    (-s2.x * s1.y + s1.x * s2.y);\n\n  if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {\n    // Collision detected\n    intersectionPoint.x = p0.x + t * s1.x;\n    intersectionPoint.y = p0.y + t * s1.y;\n    return true;\n  }\n\n  return false;\n}\n","import { sub, v2, Vector2, scale, normalize, add } from \"./v2\";\nimport { segmentIntersection } from \"./segment-intersection\";\nimport { Integratable } from \"./common-types\";\n\nconst tunnelPoint = v2();\nconst offset = v2();\n\nconst v = v2();\nconst direction = v2();\nconst radiusSegment = v2();\nconst cposIncludingRadius = v2();\n\nexport function rewindToCollisionPoint(\n  point3: Integratable,\n  radius3: number,\n  point1: Vector2,\n  point2: Vector2\n): boolean {\n  // detect if a collision has occurred but would have been missed due to\n  // point3 moving beyond the edge in one time step.\n  \n  // TODO: this should accept some sort of manifold or collision contact object,\n  // not randum args (radius, etc). Without a manifold it's imposible to know \n  // if the point \"tunneled\" due to a collision or the result of _resolving_\n  // a collision!\n\n  // Compute where the cpos would be if the segment actually included the\n  // radius.\n  // Without this, we would rewind to the point3 center, and the direction\n  // of two points colliding with each other exactly is undefined.\n  sub(v, point3.cpos, point3.ppos);\n  normalize(direction, v);\n  scale(radiusSegment, direction, radius3);\n  add(cposIncludingRadius, radiusSegment, point3.cpos);\n\n  const hasTunneled = segmentIntersection(\n    cposIncludingRadius,\n    point3.ppos,\n    point1,\n    point2,\n    tunnelPoint\n  );\n\n  if (!hasTunneled) return false;\n\n  // Translate point3 to tunnelPoint, including the radius of the point.\n  sub(offset, cposIncludingRadius, tunnelPoint);\n  \n  sub(point3.cpos, point3.cpos, offset);\n  sub(point3.ppos, point3.ppos, offset);\n  return true;\n}\n\nfunction debuggerIfNaN(point: Vector2) {\n  if (isNaN(point.x) || isNaN(point.y)) {\n    debugger;\n  }\n}\n","import {\n  Vector2,\n  sub,\n  v2,\n  normal,\n  dot,\n  distance,\n  set,\n} from \"./v2\";\n\nexport type PointEdgeProjection = {\n  // distance between the point and the projected point on the line\n  distance: number;\n  // dot product between edge normal (perp of endpoint1 -> endpoint2) and normal\n  // from edge to point. If positive, they are pointing in the same direction\n  // (aka the point is on the side of the segment in the direction of the\n  // normal). If negative, the point is on the opposite side. The absolute value\n  // of this will always match the distance.\n  similarity: number;\n  // What percentage along the line the projection is. < 0 means behind the\n  // edge, > 1 means ahead of the edge endpoints.\n  u: number;\n  // The point in absolute space of the projection along the edge\n  projectedPoint: Vector2;\n  // The normal of the edge (endpoint1 -> endpoint2): Given v1(0,0) -> v2(10, 0), the normal will be (0, 1)\n  edgeNormal: Vector2;\n};\n\n/**\n * Create a pre-made result object for tests.\n */\nexport function createPointEdgeProjectionResult(): PointEdgeProjection {\n  return {\n    distance: 0,\n    similarity: 0,\n    u: 0,\n    projectedPoint: v2(),\n    edgeNormal: v2(),\n  };\n}\n\nconst edgeDelta = v2();\nconst perp = v2();\n\nexport function projectPointEdge(\n  point: Vector2,\n  endpoint1: Vector2,\n  endpoint2: Vector2,\n  result: PointEdgeProjection\n) {\n  sub(edgeDelta, endpoint2, endpoint1);\n  if (edgeDelta.x === 0 && edgeDelta.y === 0) {\n    throw new Error('ZeroLengthEdge');\n  }\n\n  // http://paulbourke.net/geometry/pointlineplane/\n  // http://paulbourke.net/geometry/pointlineplane/DistancePoint.java\n  const u =\n    ((point.x - endpoint1.x) * edgeDelta.x + (point.y - endpoint1.y) * edgeDelta.y) /\n    (edgeDelta.x * edgeDelta.x + edgeDelta.y * edgeDelta.y);\n\n  result.u = u;\n\n  const proj = set(\n    result.projectedPoint,\n    endpoint1.x + u * edgeDelta.x,\n    endpoint1.y + u * edgeDelta.y\n  );\n\n  result.distance = distance(proj, point);\n\n  // given:\n  // E1----------------------E2        Proj\n  //           |                        |\n  //           | EdgeNorm               | perp\n  //           |                       Point\n  // \n  // What is the similarity (dot product) between EdgeNorm and Perp?\n  const edgeNorm = normal(result.edgeNormal, endpoint1, endpoint2);\n  sub(perp, point, proj);\n  result.similarity = dot(edgeNorm, perp);\n}\n","import { v2, Vector2, sub, normalize, scale, add } from \"./v2\";\nimport { Integratable } from \"./common-types\";\n\n// preallocations\nconst v = v2();\nconst direction = v2();\nconst radiusSegment = v2();\n\n/**\n * Compute the leading edge of a circular moving object given a radius: cpos + radius in the direction of velocity.\n */\nexport const projectCposWithRadius = (\n  out: Vector2,\n  p: Integratable,\n  radius: number\n) => {\n  sub(v, p.cpos, p.ppos);\n  normalize(direction, v);\n  scale(radiusSegment, direction, radius);\n  add(out, radiusSegment, p.cpos);\n  return out;\n}\n","\n// I would prefer to name all the exports here to prevent name clobbering,\n// but Babel cannot know if a named export is a Type or not. So even loading\n// this transpiled file in a project will cause failures when a builder,\n// like webpack or rollup, tries to resolve a Type as a code export.\n\nexport * from \"./accelerate\";\nexport * from \"./collide-circle-circle\";\nexport * from \"./collide-circle-edge\";\nexport * from \"./collision-response-aabb\";\nexport * from \"./solve-distance-constraint\";\nexport * from \"./solve-drag\";\nexport * from \"./solve-gravitation\";\nexport * from \"./inertia\";\nexport * from \"./overlap-aabb-aabb\";\nexport * from \"./overlap-circle-circle\";\nexport * from \"./rewind-to-collision-point\";\nexport * from \"./segment-intersection\";\nexport * from \"./v2\";\nexport * from \"./common-types\";\nexport * from './project-point-edge';\nexport * from './project-capsule';\n","import scihalt from \"science-halt\";\nimport {\n  add,\n  scale,\n  sub,\n  v2,\n  AABBOverlapResult,\n  accelerate,\n  inertia,\n  overlapAABBAABB,\n  collisionResponseAABB,\n  Vector2\n} from \"../src\";\n\ntype Box = {\n  cpos: Vector2;\n  ppos: Vector2;\n  acel: Vector2;\n  w: number;\n  h: number;\n  mass: number;\n}\n\nexport const start = () => {\n  const cvs = document.createElement(\"canvas\");\n  const ctx = cvs.getContext(\"2d\")!;\n  cvs.width = cvs.height = 800;\n  cvs.style.border = \"1px solid gray\";\n  document.body.appendChild(cvs);\n\n  const box1 = {\n    cpos: v2(350, 90),\n    ppos: v2(349, 80),\n    acel: v2(),\n    w: 100,\n    h: 150,\n    mass: 10\n  };\n\n  const box2 = {\n    cpos: v2(350, 600),\n    ppos: v2(350, 600),\n    acel: v2(),\n    w: 100,\n    h: 150,\n    mass: 10\n  };\n\n  const points: Box[] = [];\n  const collision: AABBOverlapResult = {\n    resolve: v2(),\n    hitPos: v2(),\n    normal: v2()\n  };\n\n  points.push(box1, box2);\n\n  let running = true;\n  scihalt(() => (running = false));\n\n  (function step() {\n    const dt = 1;\n    for (let i = 0; i < points.length; i++) {\n      const point = points[i];\n      accelerate(point, dt);\n    }\n\n    const isOverlapping = overlapAABBAABB(\n      box1.cpos.x,\n      box1.cpos.y,\n      box1.w,\n      box1.h,\n      box2.cpos.x,\n      box2.cpos.y,\n      box2.w,\n      box2.h,\n      collision\n    );\n\n    if (isOverlapping) {\n      // for debugging\n      render(points, ctx);\n\n      // move to non-overlapping position\n      const overlapHalf = scale(v2(), collision.resolve, 0.5);\n      add(box2.cpos, box2.cpos, overlapHalf);\n      add(box2.ppos, box2.ppos, overlapHalf);\n      sub(box1.cpos, box1.cpos, overlapHalf);\n      sub(box1.ppos, box1.ppos, overlapHalf);\n\n      // for debugging\n      render(points, ctx);\n\n      const box1v = v2();\n      const box2v = v2();\n\n      const restitution = 1;\n      const staticFriction = 0.9;\n      const dynamicFriction = 0.01;\n\n      collisionResponseAABB(\n        box1.cpos,\n        box1.ppos,\n        box1.mass,\n        restitution,\n        staticFriction,\n        dynamicFriction,\n        box2.cpos,\n        box2.ppos,\n        box2.mass,\n        restitution,\n        staticFriction,\n        dynamicFriction,\n        // Allow the response function to recompute a normal based on the\n        // axis between the centers of the boxes. this produces a more\n        // natural looking collision.\n        // collision.normal,\n        v2(),\n        box1v,\n        box2v\n      );\n\n      // Apply the new velocity\n      sub(box1.ppos, box1.cpos, box1v);\n      sub(box2.ppos, box2.cpos, box2v);\n\n      // for debugging\n      render(points, ctx);\n    }\n\n    for (let i = 0; i < points.length; i++) {\n      const point = points[i];\n      inertia(point);\n    }\n\n    render(points, ctx);\n    if (!running) return;\n    window.requestAnimationFrame(step);\n  })();\n\n  function render(points: Box[], ctx: CanvasRenderingContext2D) {\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n    for (let i = 0; i < points.length; i++) {\n      const point = points[i];\n\n      ctx.fillStyle = \"red\";\n      ctx.fillRect(\n        point.ppos.x - point.w / 2,\n        point.ppos.y - point.h / 2,\n        point.w,\n        point.h\n      );\n\n      ctx.fillStyle = \"black\";\n      ctx.fillRect(\n        point.cpos.x - point.w / 2,\n        point.cpos.y - point.h / 2,\n        point.w,\n        point.h\n      );\n    }\n  }\n};\n","import scihalt from \"science-halt\";\nimport {\n  add,\n  distance,\n  scale,\n  sub,\n  v2,\n  accelerate,\n  inertia,\n  solveGravitation,\n  overlapAABBAABB,\n  collisionResponseAABB,\n  AABBOverlapResult,\n  copy\n} from \"../src/index\";\n\nexport const start = () => {\n  const cvs = document.createElement(\"canvas\");\n  const ctx = cvs.getContext(\"2d\")!;\n  cvs.width = cvs.height = 800;\n  cvs.style.border = \"1px solid gray\";\n  document.body.appendChild(cvs);\n\n  type Box = ReturnType<typeof makeBox>;\n\n  const points: Box[] = [];\n\n  for (let count = 25, i = 0; i < count; i++) {\n    const centerX = cvs.width / 2;\n    const centerY = cvs.height / 2;\n    const distance = Math.min(centerX, centerY) * 0.5;\n    const cos = Math.cos(i);\n    const sin = Math.sin(i);\n    const x = centerX + cos * distance;\n    const y = centerY + sin * distance;\n    points.push(makeBox(x, y));\n  }\n\n  const GRAVITATIONAL_POINT = {\n    cpos: v2(cvs.width / 2, cvs.height / 2),\n    ppos: v2(cvs.width / 2, cvs.height / 2),\n    acel: v2(),\n    mass: 100000\n  };\n\n  let running = true;\n  scihalt(() => (running = false));\n\n  (function step() {\n    for (let i = 0; i < points.length; i++) {\n      const point = points[i];\n      const dist = distance(point.cpos, GRAVITATIONAL_POINT.cpos);\n      dist > 100 &&\n        solveGravitation(\n          point,\n          point.mass,\n          GRAVITATIONAL_POINT,\n          GRAVITATIONAL_POINT.mass\n        );\n    }\n\n    const dt = 1;\n    for (let i = 0; i < points.length; i++) {\n      const point = points[i];\n      accelerate(point, dt);\n    }\n\n    const collisions = [];\n    const handled = [];\n    const collision: AABBOverlapResult = {\n      resolve: v2(),\n      hitPos: v2(),\n      normal: v2()\n    };\n\n    for (let i = 0; i < points.length; i++) {\n      for (let j = i + 1; j < points.length; j++) {\n        const box1 = points[i];\n        const box2 = points[j];\n        const isOverlapping = overlapAABBAABB(\n          box1.cpos.x,\n          box1.cpos.y,\n          box1.w,\n          box1.h,\n          box2.cpos.x,\n          box2.cpos.y,\n          box2.w,\n          box2.h,\n          collision\n        );\n\n        if (\n          isOverlapping &&\n          handled.indexOf(box1.id + \",\" + box2.id) === -1 &&\n          handled.indexOf(box2.id + \",\" + box1.id) === -1\n        ) {\n          // move to non-overlapping position\n          const overlapHalf = scale(v2(), collision.resolve, 0.5);\n          add(box2.cpos, box2.cpos, overlapHalf);\n          add(box2.ppos, box2.ppos, overlapHalf);\n          sub(box1.cpos, box1.cpos, overlapHalf);\n          sub(box1.ppos, box1.ppos, overlapHalf);\n\n          // for debugging\n          render(points, ctx);\n\n          const box1v = v2();\n          const box2v = v2();\n\n          const restitution = 1;\n          const staticFriction = 0.9;\n          const dynamicFriction = 0.01;\n\n          collisionResponseAABB(\n            box1.cpos,\n            box1.ppos,\n            box1.mass,\n            restitution,\n            staticFriction,\n            dynamicFriction,\n            box2.cpos,\n            box2.ppos,\n            box2.mass,\n            restitution,\n            staticFriction,\n            dynamicFriction,\n            // Allow the response function to recompute a normal based on the\n            // axis between the centers of the boxes. this produces a more\n            // natural looking collision.\n            // collision.normal,\n            v2(),\n            box1v,\n            box2v\n          );\n\n          // Apply the new velocity\n          sub(box1.ppos, box1.cpos, box1v);\n          sub(box2.ppos, box2.cpos, box2v);\n\n          // for debugging\n          render(points, ctx);\n\n          handled.push(box1.id + \",\" + box2.id);\n          handled.push(box2.id + \",\" + box1.id);\n        }\n      }\n    }\n\n    for (let i = 0; i < points.length; i++) {\n      const point = points[i];\n      inertia(point);\n    }\n\n    render(points, ctx);\n    if (!running) return;\n    window.requestAnimationFrame(step);\n  })();\n\n  function makeBox(x: number, y: number) {\n    return {\n      id: \"id-\" + Math.floor(Math.random() * 10000000),\n      cpos: v2(x, y),\n      ppos: v2(x, y),\n      acel: v2(),\n      mass: 10,\n      w: 10,\n      h: 10\n    };\n  }\n\n  function render(points: Box[], ctx: CanvasRenderingContext2D) {\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n    for (let i = 0; i < points.length; i++) {\n      const point = points[i];\n\n      ctx.fillStyle = \"red\";\n      ctx.fillRect(\n        point.ppos.x - point.w / 2,\n        point.ppos.y - point.h / 2,\n        point.w,\n        point.h\n      );\n\n      ctx.fillStyle = \"black\";\n      ctx.fillRect(\n        point.cpos.x - point.w / 2,\n        point.cpos.y - point.h / 2,\n        point.w,\n        point.h\n      );\n    }\n  }\n};\n","import scihalt from \"science-halt\";\nimport {\n  add,\n  copy,\n  normalize,\n  scale,\n  sub,\n  v2,\n  accelerate,\n  inertia,\n  solveGravitation,\n  overlapCircleCircle,\n  collideCircleCircle,\n  Vector2\n} from \"../src/index\";\n\nexport const start = () => {\n  const cvs = document.createElement(\"canvas\");\n  const ctx = cvs.getContext(\"2d\")!;\n  cvs.width = cvs.height = 800;\n  cvs.style.border = \"1px solid gray\";\n  document.body.appendChild(cvs);\n\n  type Point = (ReturnType<typeof generatePoints>)[0];\n\n  // generate a circle of circles\n  const CENTER = { x: 400, y: 400 };\n  const GRAVITATIONAL_POINT = {\n    cpos: copy(v2(), CENTER),\n    ppos: copy(v2(), CENTER),\n    acel: v2(),\n    radius: 20,\n    mass: 10000\n  };\n  const RADIUS = 15;\n  const DAMPING = 0.1;\n  const points = generatePoints(CENTER, RADIUS, 40);\n  const colliding: Point[] = [];\n\n  points.unshift(GRAVITATIONAL_POINT);\n\n  let running = true;\n  scihalt(() => (running = false));\n\n  let ticks = 0;\n\n  (function step() {\n    const force = v2();\n    const dt = 16;\n    for (let i = 0; i < points.length; i++) {\n      const point = points[i];\n      if (point !== GRAVITATIONAL_POINT && ticks < 100) {\n        solveGravitation(\n          point,\n          point.mass,\n          GRAVITATIONAL_POINT,\n          GRAVITATIONAL_POINT.mass\n        );\n        //sub(force, GRAVITATIONAL_POINT.cpos, point.cpos);\n        //normalize(force, force);\n        //scale(force, force, 50);\n        //add(point.acel, point.acel, force);\n      }\n      accelerate(point, dt);\n    }\n\n    collisionPairs(colliding, points);\n\n    for (let i = 0; i < colliding.length; i += 2) {\n      const pointA = colliding[i];\n      const pointB = colliding[i + 1];\n      collideCircleCircle(\n        pointA,\n        pointA.radius,\n        pointA.mass,\n        pointB,\n        pointB.radius,\n        pointB.mass,\n        false,\n        DAMPING\n      );\n    }\n\n    for (let i = 0; i < points.length; i++) {\n      const point = points[i];\n      inertia(point);\n    }\n\n    // TODO: the original demo code technically \"detects\" collisions with each\n    // iteration, but when we do this, it actually becomes more unstable. \n    // collisionPairs(colliding, points);\n\n    for (let i = 0; i < colliding.length; i += 2) {\n      const pointA = colliding[i];\n      const pointB = colliding[i + 1];\n      collideCircleCircle(\n        pointA,\n        pointA.radius,\n        pointA.mass,\n        pointB,\n        pointB.radius,\n        pointB.mass,\n        true,\n        DAMPING\n      );\n    }\n\n    render(points, ctx);\n    ticks++;\n    if (!running) return;\n    window.requestAnimationFrame(step);\n  })();\n\n  function collisionPairs(pairs: Point[], points: Point[]) {\n    pairs.length = 0;\n\n    for (let i = 0; i < points.length; i++) {\n      const pointA = points[i];\n      for (let j = i + 1; j < points.length; j++) {\n        const pointB = points[j];\n        if (\n          overlapCircleCircle(\n            pointA.cpos.x,\n            pointA.cpos.y,\n            pointA.radius,\n            pointB.cpos.x,\n            pointB.cpos.y,\n            pointB.radius\n          )\n        ) {\n          pairs.push(pointA, pointB);\n        }\n      }\n    }\n\n    return pairs;\n  }\n\n  function generatePoints(center: Vector2, baseRadius: number, num: number) {\n    const all = [];\n    const minRadius = 10;\n    for (let i = 0; i < num; i++) {\n      const x = Math.cos(i) * center.x + center.x;\n      const y = Math.sin(i) * center.y + center.y;\n      all.push({\n        cpos: { x, y },\n        ppos: { x, y },\n        acel: { x: 0, y: 0 },\n        radius: Math.max(\n          Math.abs(Math.cos(i) + Math.sin(i)) * baseRadius,\n          minRadius\n        ),\n        mass: Math.max(Math.abs(Math.cos(i) + Math.sin(i)) * 1, 1)\n      });\n    }\n    return all;\n  }\n\n  function render(points: Point[], ctx: CanvasRenderingContext2D) {\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n    for (let i = 0; i < points.length; i++) {\n      const point = points[i];\n\n      ctx.fillStyle = \"red\";\n      ctx.beginPath();\n      ctx.arc(point.ppos.x, point.ppos.y, point.radius, 0, Math.PI * 2, false);\n      ctx.fill();\n\n      ctx.fillStyle = \"black\";\n      ctx.beginPath();\n      ctx.arc(point.cpos.x, point.cpos.y, point.radius, 0, Math.PI * 2, false);\n      ctx.fill();\n    }\n  }\n};\n","import scihalt from \"science-halt\";\nimport {\n  add,\n  copy,\n  normalize,\n  scale,\n  sub,\n  v2,\n  accelerate,\n  inertia,\n  solveGravitation,\n  overlapCircleCircle,\n  collideCircleCircle,\n  collideCircleEdge,\n  solveDistanceConstraint,\n  rewindToCollisionPoint,\n  Vector2,\n  VelocityDerivable,\n  distance,\n  Integratable\n} from \"../src/index\";\n\nexport const start = () => {\n  const cvs = document.createElement(\"canvas\");\n  const ctx = cvs.getContext(\"2d\")!;\n  cvs.width = cvs.height = 800;\n  cvs.style.border = \"1px solid gray\";\n  document.body.appendChild(cvs);\n\n  type CollidableLine = {\n    point1: CollidableCircle;\n    point2: CollidableCircle;\n  };\n\n  type CollidableCircle = {\n    mass: number;\n    radius: number;\n  } & Integratable;\n\n  type DistanceConstraint = {\n    point1: Exclude<CollidableCircle, \"radius\">;\n    point2: Exclude<CollidableCircle, \"radius\">;\n    goal: number;\n  };\n\n  const CONSTRAINT_ITERATIONS = 2;\n\n  const circles: CollidableCircle[] = [];\n  const lines: CollidableLine[] = [];\n  const constraints: DistanceConstraint[] = [];\n\n  const box = makeBox(300, 200, 100, 200);\n  circles.push(...box.circles);\n  lines.push(...box.lines);\n  constraints.push(...box.constraints);\n\n  circles.push({\n    cpos: v2(500, 390),\n    ppos: v2(510, 390),\n    acel: v2(0, 0),\n    mass: 100,\n    radius: 10\n  });\n\n  let running = true;\n  scihalt(() => (running = false));\n\n  (function step() {\n    const dt = 16;\n\n    for (let i = 0; i < circles.length; i++) {\n      const circle = circles[i];\n      accelerate(circle, dt);\n    }\n\n    for (let i = 0; i < CONSTRAINT_ITERATIONS; i++) {\n      for (let j = 0; j < constraints.length; j++) {\n        const constraint = constraints[j];\n        solveDistanceConstraint(\n          constraint.point1,\n          constraint.point1.mass,\n          constraint.point2,\n          constraint.point2.mass,\n          constraint.goal\n        );\n      }\n    }\n\n    collideCircles(circles, false);\n    collideEdges(lines, circles, false);\n\n    for (let i = 0; i < circles.length; i++) {\n      const circle = circles[i];\n      inertia(circle);\n    }\n\n    collideCircles(circles, true);\n    collideEdges(lines, circles, true);\n\n    render(circles, lines, ctx);\n    if (!running) return;\n    window.requestAnimationFrame(step);\n  })();\n\n  function makeBox(x: number, y: number, width: number, height: number) {\n    const lines: CollidableLine[] = [];\n    const circles: CollidableCircle[] = [];\n    const constraints: DistanceConstraint[] = [];\n    const points = [\n      v2(x, y),\n      v2(x + width, y),\n      v2(x + width, y + height),\n      v2(x, y + height)\n    ];\n    for (let i = 0; i < points.length; i++) {\n      const point = points[i];\n      const prev = circles.length === 0 ? null : circles[i - 1];\n      const circle = {\n        cpos: copy(v2(), point),\n        ppos: copy(v2(), point),\n        acel: v2(0, 0),\n        mass: i === 0 ? -1 : 1,\n        radius: 1\n      };\n      if (prev) {\n        lines.push({\n          point1: prev,\n          point2: circle\n        });\n\n        constraints.push({\n          point1: prev,\n          point2: circle,\n          goal: distance(point, prev.cpos)\n        });\n      }\n      circles.push(circle);\n    }\n\n    lines.push({\n      point1: circles[circles.length - 1],\n      point2: circles[0]\n    });\n\n    constraints.push({\n      point1: circles[circles.length - 1],\n      point2: circles[0],\n      goal: distance(circles[circles.length - 1].cpos, circles[0].cpos)\n    });\n\n    constraints.push({\n      point1: circles[0],\n      point2: circles[2],\n      goal: distance(circles[0].cpos, circles[2].cpos)\n    });\n\n    return {\n      lines,\n      circles,\n      constraints\n    };\n  }\n\n  function collideCircles(\n    circles: CollidableCircle[],\n    preserveInertia: boolean,\n    damping = 0.9\n  ) {\n    for (let i = 0; i < circles.length; i++) {\n      const a = circles[i];\n      for (let j = i + 1; j < circles.length; j++) {\n        const b = circles[j];\n        if (\n          !overlapCircleCircle(\n            a.cpos.x,\n            a.cpos.y,\n            a.radius,\n            b.cpos.x,\n            b.cpos.y,\n            b.radius\n          )\n        )\n          continue;\n        collideCircleCircle(\n          a,\n          a.radius,\n          a.mass,\n          b,\n          b.radius,\n          b.mass,\n          preserveInertia,\n          damping\n        );\n      }\n    }\n  }\n\n  function collideEdges(\n    lines: CollidableLine[],\n    circles: CollidableCircle[],\n    preserveInertia: boolean,\n    damping = 0.9\n  ) {\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i];\n      for (let j = 0; j < circles.length; j++) {\n        const circle = circles[j];\n        // Don't collide with yourself! This would be very very bad.\n        if (line.point1 == circle || line.point2 === circle) continue;\n        if (!preserveInertia)\n          rewindToCollisionPoint(\n            circle,\n            circle.radius,\n            line.point1.cpos,\n            line.point2.cpos\n          );\n        collideCircleEdge(\n          circle,\n          circle.radius,\n          circle.mass,\n          line.point1,\n          line.point1.mass,\n          line.point2,\n          line.point2.mass,\n          preserveInertia,\n          damping\n        );\n      }\n    }\n  }\n\n  function render(\n    circles: CollidableCircle[],\n    segments: CollidableLine[],\n    ctx: CanvasRenderingContext2D\n  ) {\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n    for (let i = 0; i < circles.length; i++) {\n      const point = circles[i];\n\n      ctx.fillStyle = \"red\";\n      ctx.beginPath();\n      ctx.arc(point.ppos.x, point.ppos.y, point.radius, 0, Math.PI * 2, false);\n      ctx.fill();\n\n      ctx.fillStyle = \"black\";\n      ctx.beginPath();\n      ctx.arc(point.cpos.x, point.cpos.y, point.radius, 0, Math.PI * 2, false);\n      ctx.fill();\n    }\n\n    for (let i = 0; i < segments.length; i++) {\n      const segment = segments[i];\n      ctx.strokeStyle = \"red\";\n      ctx.beginPath();\n      ctx.moveTo(segment.point1.ppos.x, segment.point1.ppos.y);\n      ctx.lineTo(segment.point2.ppos.x, segment.point2.ppos.y);\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.strokeStyle = \"black\";\n      ctx.moveTo(segment.point1.cpos.x, segment.point1.cpos.y);\n      ctx.lineTo(segment.point2.cpos.x, segment.point2.cpos.y);\n      ctx.stroke();\n    }\n  }\n};\n","import scihalt from \"science-halt\";\nimport {\n  Vector2,\n  v2,\n  accelerate,\n  inertia,\n  add,\n  collideCircleEdge,\n  rewindToCollisionPoint,\n  solveDistanceConstraint\n} from \"../src\";\n\nexport const start = () => {\n  const cvs = document.createElement(\"canvas\");\n  const ctx = cvs.getContext(\"2d\")!;\n  cvs.tabIndex = 1; // for keyboard events\n  cvs.width = cvs.height = 800;\n  cvs.style.border = \"1px solid gray\";\n  document.body.appendChild(cvs);\n\n  type CollidableLine = {\n    point1: CollidableCircle;\n    point2: CollidableCircle;\n    goal: number;\n  };\n\n  type CollidableCircle = {\n    cpos: Vector2;\n    ppos: Vector2;\n    acel: Vector2;\n    mass: number;\n    radius: number;\n  };\n\n  const player: CollidableCircle = {\n    cpos: v2(600, 0),\n    ppos: v2(600, 0),\n    acel: v2(0, 0),\n    mass: 1,\n    radius: 20\n  };\n\n  const GRAVITY = 0.8;\n\n  const platform: CollidableLine = {\n    point1: {\n      cpos: v2(100, 300),\n      ppos: v2(100, 300),\n      acel: v2(0, 0),\n      // mass: 100000000,\n      mass: -1,\n      radius: 0\n    },\n    point2: {\n      cpos: v2(700, 300),\n      ppos: v2(700, 300),\n      acel: v2(0, 0),\n      // mass: 100000000,\n      // mass: -1,\n      mass: -1,\n      radius: 0\n    },\n    goal: 500\n  };\n\n  const circles: CollidableCircle[] = [\n    player,\n    platform.point1,\n    platform.point2\n  ];\n\n  const tunnelPoint = v2();\n\n  let running = true;\n  scihalt(() => (running = false));\n\n  // const keys: { [key: string]: boolean } = {};\n  // cvs.addEventListener(\"keydown\", e => {\n  //   keys[e.key] = true;\n  //   e.preventDefault();\n  // });\n  // document.body.addEventListener(\"keyup\", e => {\n  //   keys[e.key] = false;\n  //   e.preventDefault();\n  // });\n\n  (function step() {\n    const dt = 16;\n\n    // gravity!\n    add(player.acel, player.acel, v2(0, GRAVITY));\n\n    for (let i = 0; i < circles.length; i++) {\n      const box = circles[i];\n      accelerate(box, dt);\n    }\n\n    rewindToCollisionPoint(player, player.radius, platform.point1.cpos, platform.point2.cpos);\n\n    collideCircleEdge(\n      player,\n      player.radius,\n      player.mass,\n      platform.point1,\n      platform.point1.mass,\n      platform.point2,\n      platform.point2.mass,\n      false,\n      0.9\n    );\n\n    for (let i = 0; i < circles.length; i++) {\n      const box = circles[i];\n      inertia(box);\n    }\n\n    collideCircleEdge(\n      player,\n      player.radius,\n      player.mass,\n      platform.point1,\n      platform.point1.mass,\n      platform.point2,\n      platform.point2.mass,\n      true,\n      0.9\n    );\n\n    for (let i = 0; i < 5; i++) {\n      solveDistanceConstraint(\n        platform.point1,\n        platform.point1.mass,\n        platform.point2,\n        platform.point2.mass,\n        platform.goal\n      );\n    }\n\n    render(circles, [platform], ctx);\n    if (!running) return;\n    window.requestAnimationFrame(step);\n  })();\n\n  function render(\n    circles: CollidableCircle[],\n    segments: CollidableLine[],\n    ctx: CanvasRenderingContext2D\n  ) {\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n    for (let i = 0; i < circles.length; i++) {\n      const point = circles[i];\n\n      ctx.fillStyle = \"red\";\n      ctx.beginPath();\n      ctx.arc(point.ppos.x, point.ppos.y, point.radius, 0, Math.PI * 2, false);\n      ctx.fill();\n\n      ctx.fillStyle = \"black\";\n      ctx.beginPath();\n      ctx.arc(point.cpos.x, point.cpos.y, point.radius, 0, Math.PI * 2, false);\n      ctx.fill();\n    }\n\n    for (let i = 0; i < segments.length; i++) {\n      const segment = segments[i];\n      ctx.strokeStyle = \"red\";\n      ctx.beginPath();\n      ctx.moveTo(segment.point1.ppos.x, segment.point1.ppos.y);\n      ctx.lineTo(segment.point2.ppos.x, segment.point2.ppos.y);\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.strokeStyle = \"black\";\n      ctx.moveTo(segment.point1.cpos.x, segment.point1.cpos.y);\n      ctx.lineTo(segment.point2.cpos.x, segment.point2.cpos.y);\n      ctx.stroke();\n    }\n  }\n};\n","import scihalt from \"science-halt\";\nimport {\n  Vector2,\n  v2,\n  accelerate,\n  overlapAABBAABB,\n  AABBOverlapResult,\n  inertia,\n  add,\n  scale,\n  collisionResponseAABB,\n  sub,\n  translate\n} from \"../src\";\n\nexport const start = () => {\n  const cvs = document.createElement(\"canvas\");\n  const ctx = cvs.getContext(\"2d\")!;\n  cvs.tabIndex = 1; // for keyboard events\n  cvs.width = cvs.height = 800;\n  cvs.style.border = \"1px solid gray\";\n  document.body.appendChild(cvs);\n\n  type CollidableBox = {\n    cpos: Vector2;\n    ppos: Vector2;\n    acel: Vector2;\n    width: number;\n    height: number;\n    mass: number;\n  };\n\n  const player: CollidableBox = {\n    cpos: v2(400, 0),\n    ppos: v2(400, 0),\n    acel: v2(0, 0),\n    width: 50,\n    height: 75,\n    mass: 1\n  };\n\n  const PLAYER_HOR_ACEL = 5;\n  const GRAVITY = 9.8;\n\n  const platform: CollidableBox = {\n    cpos: v2(400, 700),\n    ppos: v2(400, 700),\n    acel: v2(0, 0),\n    width: 800,\n    height: 100,\n    mass: Number.MAX_SAFE_INTEGER - 100000\n  };\n\n  const boxes: CollidableBox[] = [player, platform];\n\n  const collision: AABBOverlapResult = {\n    resolve: v2(),\n    hitPos: v2(),\n    normal: v2()\n  };\n\n  let running = true;\n  scihalt(() => (running = false));\n\n  const keys: { [key: string]: boolean } = {};\n  cvs.addEventListener(\"keydown\", e => {\n    keys[e.key] = true;\n    e.preventDefault();\n  });\n  document.body.addEventListener(\"keyup\", e => {\n    keys[e.key] = false;\n    e.preventDefault();\n  });\n\n  (function step() {\n    const dt = 16;\n\n    // gravity!\n    add(player.acel, player.acel, v2(0, GRAVITY));\n\n    for (let i = 0; i < boxes.length; i++) {\n      const box = boxes[i];\n      accelerate(box, dt);\n    }\n\n    const isOverlapping = overlapAABBAABB(\n      player.cpos.x,\n      player.cpos.y,\n      player.width,\n      player.height,\n      platform.cpos.x,\n      platform.cpos.y,\n      platform.width,\n      platform.height,\n      collision\n    );\n\n    if (isOverlapping) {\n      // Move to non-overlapping positions\n      const negativeResolve = scale(v2(), collision.resolve, -1);\n      // translate(overlapHalf, platform.cpos, platform.ppos);\n      translate(negativeResolve, player.cpos, player.ppos);\n\n      // for debugging\n      render(boxes, ctx);\n\n      // We will put the new relative velocity vectors here.\n      const box1v = v2();\n      const box2v = v2();\n\n      const restitution = 1;\n      const staticFriction = 0.9;\n      const dynamicFriction = 0.1;\n\n      collisionResponseAABB(\n        player.cpos,\n        player.ppos,\n        player.mass,\n        restitution,\n        staticFriction,\n        dynamicFriction,\n        platform.cpos,\n        platform.ppos,\n        platform.mass,\n        restitution,\n        staticFriction,\n        dynamicFriction,\n        collision.normal,\n        box1v,\n        box2v\n      );\n\n      // Apply the new velocity\n      sub(player.ppos, player.cpos, box1v);\n      // Kill vertical velocity\n      player.ppos.y = player.cpos.y;\n\n      // for debugging\n      render(boxes, ctx);\n    }\n\n    // Movement in the air is less powerful than on the ground!\n\n    if (keys.ArrowLeft) {\n      add(\n        player.acel,\n        player.acel,\n        v2(isOverlapping ? -PLAYER_HOR_ACEL : -PLAYER_HOR_ACEL / 10, 0)\n      );\n    }\n\n    if (keys.ArrowRight) {\n      add(\n        player.acel,\n        player.acel,\n        v2(isOverlapping ? PLAYER_HOR_ACEL : PLAYER_HOR_ACEL / 10, 0)\n      );\n    }\n\n    // we were overlapping, so probably ok to jump!\n    if (isOverlapping && keys.ArrowUp && player.cpos.y - player.ppos.y === 0) {\n      add(player.acel, player.acel, v2(0, -GRAVITY * 10));\n    }\n\n    for (let i = 0; i < boxes.length; i++) {\n      const box = boxes[i];\n      inertia(box);\n    }\n\n    render(boxes, ctx);\n    if (!running) return;\n    window.requestAnimationFrame(step);\n  })();\n\n  function render(boxes: CollidableBox[], ctx: CanvasRenderingContext2D) {\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n    for (let i = 0; i < boxes.length; i++) {\n      const box = boxes[i];\n\n      ctx.fillStyle = \"red\";\n      ctx.fillRect(\n        box.ppos.x - box.width / 2,\n        box.ppos.y - box.height / 2,\n        box.width,\n        box.height\n      );\n\n      ctx.fillStyle = \"black\";\n      ctx.fillRect(\n        box.cpos.x - box.width / 2,\n        box.cpos.y - box.height / 2,\n        box.width,\n        box.height\n      );\n    }\n  }\n};\n","import scihalt from \"science-halt\";\nimport {\n  Vector2,\n  v2,\n  copy,\n  accelerate,\n  inertia,\n  add,\n  distance,\n  collideCircleEdge,\n  rewindToCollisionPoint,\n  collideCircleCircle,\n  overlapCircleCircle,\n  segmentIntersection,\n  sub,\n  normalize,\n  scale,\n  normal,\n  dot,\n  solveDistanceConstraint,\n  projectPointEdge,\n  PointEdgeProjection,\n  createPointEdgeProjectionResult\n} from \"../src\";\n\nexport const start = () => {\n  const width = 800;\n  const cvs = document.createElement(\"canvas\");\n  const ctx = cvs.getContext(\"2d\")!;\n  cvs.tabIndex = 1; // for keyboard events\n  cvs.width = cvs.height = width;\n  cvs.style.border = \"1px solid gray\";\n  document.body.appendChild(cvs);\n\n  type CollidableLine = {\n    point1: CollidableCircle;\n    point2: CollidableCircle;\n  };\n\n  type CollidableCircle = {\n    cpos: Vector2;\n    ppos: Vector2;\n    acel: Vector2;\n    mass: number;\n    radius: number;\n  };\n\n  type DistanceConstraint = {\n    point1: Exclude<CollidableCircle, \"radius\">;\n    point2: Exclude<CollidableCircle, \"radius\">;\n    goal: number;\n  };\n\n  const GRAVITY = 0.8;\n  const CONSTRAINT_ITERS = 5;\n\n  const lines: CollidableLine[] = [];\n  const constraints: DistanceConstraint[] = [];\n  const circles: CollidableCircle[] = [];\n\n  const bucket = makeStaticMesh([\n    v2(50, 50),\n    v2(width - 50, 50),\n    v2(width - 50, width - 50),\n    v2(50, width - 50)\n  ]);\n\n  const midLine = makeStaticMesh([\n    v2(500, width / 2),\n    v2(width - 500, width / 2 + 200)\n  ]);\n  midLine.pop(); // remove the double link back to beginning\n  lines.push(...bucket, ...midLine);\n\n  circles.push(...makeCircles(v2(width / 2, width / 2), width / 4, 10, 400));\n\n  const polys = [\n    makePolygon(6, v2(300, 100), 15),\n    makePolygon(3, v2(400, 100), 15),\n    makePolygon(4, v2(600, 100), 15),\n  ];\n\n  polys.forEach(poly => {\n    circles.push(...poly.circles);\n    constraints.push(...poly.constraints);\n    lines.push(...poly.lines);\n  });\n\n  let running = true;\n  scihalt(() => (running = false));\n\n  (function step() {\n    const dt = 16;\n\n    for (let i = 0; i < circles.length; i++) {\n      const circle = circles[i];\n\n      if (circle.mass > 0) {\n        add(circle.acel, circle.acel, v2(0, GRAVITY));\n      }\n\n      accelerate(circle, dt);\n    }\n\n    for (let i = 0; i < CONSTRAINT_ITERS; i++) {\n      for (let j = 0; j < constraints.length; j++) {\n        const constraint = constraints[j];\n        solveDistanceConstraint(\n          constraint.point1,\n          constraint.point1.mass,\n          constraint.point2,\n          constraint.point2.mass,\n          constraint.goal,\n          1\n        );\n      }\n    }\n\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i];\n      const lineIsBounds = bucket.indexOf(line) > -1;\n      for (let j = 0; j < circles.length; j++) {\n        const circle = circles[j];\n        if (circle === line.point1 || circle === line.point2) continue;\n        // TODO: this needs to be smarter. Without this rewind, simple circles\n        // will tunnel through the line. But if done indiscriminately, the rewind\n        // will cause an infinite build up of velocity, and eventually explode. OR\n        // it will cause a circle to \"stick\" to an edge until their velocity\n        // dissipates.\n        if (!lineIsBounds) {\n          rewindToCollisionPoint(circle, circle.radius, line.point1.cpos, line.point2.cpos);\n        }\n        \n        collideCircleEdge(\n          circle,\n          circle.radius,\n          circle.mass,\n          line.point1,\n          line.point1.mass,\n          line.point2,\n          line.point2.mass,\n          false,\n          0.9\n        );\n      }\n    }\n\n    for (let i = 0; i < circles.length; i++) {\n      const a = circles[i];\n      for (let j = i + 1; j < circles.length; j++) {\n        const b = circles[j];\n        if (\n          !overlapCircleCircle(\n            a.cpos.x,\n            a.cpos.y,\n            a.radius,\n            b.cpos.x,\n            b.cpos.y,\n            b.radius\n          )\n        )\n          continue;\n        collideCircleCircle(\n          a,\n          a.radius,\n          a.mass,\n          b,\n          b.radius,\n          b.mass,\n          false,\n          0.9\n        );\n      }\n    }\n\n    for (let i = 0; i < circles.length; i++) {\n      const circle = circles[i];\n      inertia(circle);\n    }\n\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i];\n      for (let j = 0; j < circles.length; j++) {\n        const circle = circles[j];\n        if (circle === line.point1 || circle === line.point2) continue;\n        collideCircleEdge(\n          circle,\n          circle.radius,\n          circle.mass,\n          line.point1,\n          line.point1.mass,\n          line.point2,\n          line.point2.mass,\n          true,\n          0.9\n        );\n      }\n    }\n\n    for (let i = 0; i < circles.length; i++) {\n      const a = circles[i];\n      for (let j = i + 1; j < circles.length; j++) {\n        const b = circles[j];\n        if (\n          !overlapCircleCircle(\n            a.cpos.x,\n            a.cpos.y,\n            a.radius,\n            b.cpos.x,\n            b.cpos.y,\n            b.radius\n          )\n        )\n          continue;\n        collideCircleCircle(\n          a,\n          a.radius,\n          a.mass,\n          b,\n          b.radius,\n          b.mass,\n          true,\n          0.9\n        );\n      }\n    }\n\n    // Ensure nothing actually gets out of the bucket.\n    // It's impossible to keep everything in the bucket without a strict\n    // normal for each edge, because you need to know which \"side\" of the edge\n    // the particle is on. Additionally, the solver steps above can easily move\n    // a circle to a non-intersecting position that is beyond the \"knowledge\" of\n    // anything checking for collisions with edges. This is especially common\n    // when lots of collisions are being resolved.\n    for (let i = 0; i < bucket.length; i++) {\n      const line = bucket[i];\n      // HACK: Don't use the midline collection for bounds checking.\n      // The right way to do this is to create systems.\n      if (line === midLine[0]) continue;\n\n      for (let j = 0; j < circles.length; j++) {\n        const circle = circles[j];\n\n        const projection = createPointEdgeProjectionResult();\n\n        // We know which way the edges were wound, so we implicitly know which order\n        // these points should be used in to compute the normal.\n        projectPointEdge(circle.cpos, line.point1.cpos, line.point2.cpos, projection);\n\n        // both the edge normal and the segment from edge to circle are\n        // facing a similar direction\n        // We only know it is > 0 because of the order line.point,point2 were inputted\n        // into the projection.\n        if (projection.similarity > 0) continue;\n\n        // If we get here, the directions so dissimilar that the circle must\n        // be on the other side of the edge! Move it back!\n        const offset = v2();\n        sub(offset, projection.projectedPoint, circle.cpos);\n        add(circle.cpos, circle.cpos, offset);\n        // Don't correct ppos, otherwise velocity will continue to increase\n        // forever.\n        // add(circle.ppos, circle.ppos, offset);\n      }\n    }\n\n    render(circles, lines, constraints, ctx);\n    if (!running) return;\n    window.requestAnimationFrame(step);\n  })();\n\n  function makeStaticMesh(points: Vector2[]) {\n    const clines: CollidableLine[] = [];\n    const circles: CollidableCircle[] = [];\n    for (let i = 0; i < points.length; i++) {\n      const point = points[i];\n      const prev = circles.length === 0 ? null : circles[i - 1];\n      const circle = {\n        cpos: copy(v2(), point),\n        ppos: copy(v2(), point),\n        acel: v2(0, 0),\n        mass: -1,\n        radius: 1\n      };\n      if (prev) {\n        const line = {\n          point1: prev,\n          point2: circle\n        };\n        clines.push(line);\n      }\n      circles.push(circle);\n    }\n\n    clines.push({\n      point1: circles[circles.length - 1],\n      point2: circles[0]\n    });\n\n    return clines;\n  }\n\n  function makeCircles(\n    center: Vector2,\n    spawnRadius: number,\n    baseRadius: number,\n    num: number\n  ): CollidableCircle[] {\n    const all = [];\n    const minRadius = 10;\n    for (let i = 0; i < num; i++) {\n      const x = center.x + Math.cos(i) * spawnRadius;\n      const y = center.y + Math.sin(i) * spawnRadius;\n      all.push({\n        cpos: { x, y },\n        ppos: { x, y },\n        acel: { x: 0, y: 0 },\n        radius: Math.max(\n          Math.abs(Math.cos(i) + Math.sin(i)) * baseRadius,\n          minRadius\n        ),\n        mass: Math.max(Math.abs(Math.cos(i) + Math.sin(i)) * 1, 1)\n      });\n    }\n    return all;\n  }\n\n  function makePolygon(gon: number, center: Vector2, radius: number) {\n    const clines: CollidableLine[] = [];\n    const circles: CollidableCircle[] = [];\n    const constraints: DistanceConstraint[] = [];\n    for (let i = 0; i < gon; i++) {\n      const x = center.x + Math.cos((i / gon) * Math.PI * 2) * radius;\n      const y = center.y + Math.sin((i / gon) * Math.PI * 2) * radius;\n      circles.push({\n        cpos: { x, y },\n        ppos: { x, y },\n        acel: { x: 0, y: 0 },\n        radius: 5,\n        mass: 5\n      });\n    }\n\n    for (let i = 0; i < circles.length; i++) {\n      const point1 = circles[i];\n      const point2 = i === circles.length - 1 ? circles[0] : circles[i + 1];\n      clines.push({\n        point1,\n        point2\n      });\n    }\n\n    for (let i = 0; i < circles.length; i++) {\n      const point1 = circles[i];\n      let j = i;\n      while (true) {\n        j++;\n        const point2 = circles[j % circles.length];\n        if (point2 === point1) break;\n        if (\n          constraints.find(\n            c =>\n              (c.point1 === point1 && c.point2 === point2) ||\n              (c.point2 === point1 && c.point1 === point2)\n          ) !== undefined\n        )\n          break;\n        constraints.push({\n          point1,\n          point2,\n          goal: distance(point1.cpos, point2.cpos)\n        });\n      }\n    }\n\n    return {\n      circles,\n      lines: clines,\n      constraints\n    };\n  }\n\n  function render(\n    circles: CollidableCircle[],\n    segments: CollidableLine[],\n    constraints: DistanceConstraint[],\n    ctx: CanvasRenderingContext2D\n  ) {\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n    for (let i = 0; i < circles.length; i++) {\n      const point = circles[i];\n\n      ctx.fillStyle = \"red\";\n      ctx.beginPath();\n      ctx.arc(point.ppos.x, point.ppos.y, point.radius, 0, Math.PI * 2, false);\n      ctx.fill();\n\n      ctx.fillStyle = \"black\";\n      ctx.beginPath();\n      ctx.arc(point.cpos.x, point.cpos.y, point.radius, 0, Math.PI * 2, false);\n      ctx.fill();\n    }\n\n    for (let i = 0; i < segments.length; i++) {\n      const segment = segments[i];\n      ctx.strokeStyle = \"red\";\n      ctx.beginPath();\n      ctx.moveTo(segment.point1.ppos.x, segment.point1.ppos.y);\n      ctx.lineTo(segment.point2.ppos.x, segment.point2.ppos.y);\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.strokeStyle = \"black\";\n      ctx.moveTo(segment.point1.cpos.x, segment.point1.cpos.y);\n      ctx.lineTo(segment.point2.cpos.x, segment.point2.cpos.y);\n      ctx.stroke();\n    }\n\n    for (let i = 0; i < constraints.length; i++) {\n      const c = constraints[i];\n      ctx.strokeStyle = \"magenta\";\n      ctx.beginPath();\n      ctx.moveTo(c.point1.ppos.x, c.point1.ppos.y);\n      ctx.lineTo(c.point2.ppos.x, c.point2.ppos.y);\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.strokeStyle = \"purple\";\n      ctx.moveTo(c.point1.cpos.x, c.point1.cpos.y);\n      ctx.lineTo(c.point2.cpos.x, c.point2.cpos.y);\n      ctx.stroke();\n    }\n  }\n};\n","import scihalt from \"science-halt\";\nimport {\n  Vector2,\n  v2,\n  accelerate,\n  inertia,\n  add,\n  rewindToCollisionPoint,\n  solveDistanceConstraint,\n  collisionResponseAABB,\n  createPointEdgeProjectionResult,\n  projectPointEdge,\n  sub,\n  segmentIntersection,\n  projectCposWithRadius,\n  translate,\n} from \"../src\";\n\nexport const start = () => {\n  const cvs = document.createElement(\"canvas\");\n  const ctx = cvs.getContext(\"2d\")!;\n  cvs.tabIndex = 1; // for keyboard events\n  cvs.width = cvs.height = 800;\n  cvs.style.border = \"1px solid gray\";\n  document.body.appendChild(cvs);\n\n  type CollidableLine = {\n    point1: CollidableCircle;\n    point2: CollidableCircle;\n    goal: number;\n  };\n\n  type CollidableCircle = {\n    cpos: Vector2;\n    ppos: Vector2;\n    acel: Vector2;\n    mass: number;\n    radius: number;\n  };\n\n  const player: CollidableCircle = {\n    cpos: v2(600, 100),\n    ppos: v2(600, 100),\n    acel: v2(0, 0),\n    mass: 1,\n    radius: 20,\n  };\n\n  const GRAVITY = 0.98;\n\n  // Use similar masses because even if the platform is immobile, a huge mass\n  // will impart nearly all velocity into the ball, and make restitution and\n  // friction nearly meaningless.\n  const platform: CollidableLine = {\n    point1: {\n      cpos: v2(100, 300),\n      ppos: v2(100, 300),\n      acel: v2(0, 0),\n      mass: 1,\n      radius: 0,\n    },\n    point2: {\n      cpos: v2(700, 300),\n      ppos: v2(700, 300),\n      acel: v2(0, 0),\n      mass: 1,\n      radius: 0,\n    },\n    goal: 500,\n  };\n\n  const circles: CollidableCircle[] = [\n    player,\n    platform.point1,\n    platform.point2,\n  ];\n\n  let running = true;\n  scihalt(() => (running = false));\n\n  (function step() {\n    const dt = 16;\n\n    // gravity!\n    add(player.acel, player.acel, v2(0, GRAVITY));\n\n    for (let i = 0; i < circles.length; i++) {\n      const box = circles[i];\n      accelerate(box, dt);\n    }\n\n    // Use the ppos to account for tunneling: if the ppos->cpos vector is\n    // intersecting with the edge, and ppos is still >0, that means the circle\n    // has collided or even tunneled.\n    const projectedResult = createPointEdgeProjectionResult();\n    projectPointEdge(\n      player.ppos,\n      platform.point1.cpos,\n      platform.point2.cpos,\n      projectedResult\n    );\n\n    // Project the cpos using the radius just for the sake of doing a\n    // line-intersection. Technically we don't have to do this line segment\n    // intersetion test because rewindToCollisionPoint will do it internally,\n    // but it's useful to know if it _will_ rewind or not, and sadly the rewind\n    // function mutates. This can be a problem in environments with more than\n    // one collision happening per frame.\n    const intersectionPoint = v2();\n    const cposCapsule = projectCposWithRadius(v2(), player, player.radius);\n    const intersected = segmentIntersection(player.ppos, cposCapsule, platform.point1.cpos, platform.point2.cpos, intersectionPoint);\n\n    if (intersected && projectedResult.similarity < 0) {\n      // Do our best to prevent tunneling: rewind by the distance from the cpos\n      // capsule to the segment intersection point. `Translate` adds, so we have\n      // to sub intersectionPoint - capsule, which is slightly counterintuitive.\n      const offset = v2();\n      sub(offset,intersectionPoint, cposCapsule);\n      translate(offset, player.cpos, player.ppos);\n\n      const vout1 = v2();\n      const vout2 = v2();\n\n      // 1: nearly perfectly elastic (we still lose some energy due to gravity)\n      // 0: dead\n      const restitution = 1;\n\n      collisionResponseAABB(\n        player.cpos,\n        player.ppos,\n        player.mass,\n        restitution,\n        0.9,\n        0.1,\n        projectedResult.projectedPoint,\n        projectedResult.projectedPoint,\n        (platform.point1.mass + platform.point2.mass) * projectedResult.u,\n        restitution,\n        0.9,\n        0.1,\n        projectedResult.edgeNormal,\n        vout1,\n        vout2\n      );\n\n      sub(player.ppos, player.cpos, vout1);\n      // preserve systemic energy by giving the velocity that would have been\n      // imparted to the edge (if it were moveable) to the ball instead.\n      add(player.ppos, player.ppos, vout2);\n    }\n\n    for (let i = 0; i < circles.length; i++) {\n      const box = circles[i];\n      inertia(box);\n    }\n\n    for (let i = 0; i < 5; i++) {\n      // Not really necessary since we're never imparting velocity to the\n      // platform, but could be useful to demonstrate how to keep the shape if\n      // we did.\n      solveDistanceConstraint(\n        platform.point1,\n        platform.point1.mass,\n        platform.point2,\n        platform.point2.mass,\n        platform.goal\n      );\n    }\n\n    render(circles, [platform], ctx);\n    if (!running) return;\n    window.requestAnimationFrame(step);\n  })();\n\n  function render(\n    circles: CollidableCircle[],\n    segments: CollidableLine[],\n    ctx: CanvasRenderingContext2D\n  ) {\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n    for (let i = 0; i < circles.length; i++) {\n      const point = circles[i];\n\n      ctx.fillStyle = \"red\";\n      ctx.beginPath();\n      ctx.arc(point.ppos.x, point.ppos.y, point.radius, 0, Math.PI * 2, false);\n      ctx.fill();\n\n      ctx.fillStyle = \"black\";\n      ctx.beginPath();\n      ctx.arc(point.cpos.x, point.cpos.y, point.radius, 0, Math.PI * 2, false);\n      ctx.fill();\n    }\n\n    for (let i = 0; i < segments.length; i++) {\n      const segment = segments[i];\n      ctx.strokeStyle = \"red\";\n      ctx.beginPath();\n      ctx.moveTo(segment.point1.ppos.x, segment.point1.ppos.y);\n      ctx.lineTo(segment.point2.ppos.x, segment.point2.ppos.y);\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.strokeStyle = \"black\";\n      ctx.moveTo(segment.point1.cpos.x, segment.point1.cpos.y);\n      ctx.lineTo(segment.point2.cpos.x, segment.point2.cpos.y);\n      ctx.stroke();\n    }\n  }\n};\n","import * as AABBOverlapDemo from \"./aabb-overlap\";\nimport * as AABBSoupDemo from \"./aabb-soup\";\nimport * as CircleCollisions from \"./circle-collisions\";\nimport * as CircleBoxCollision from \"./circle-box-collision\";\nimport * as EdgeCollision from \"./edge-collision\";\nimport * as Platformer from \"./platformer\";\nimport * as Bucket from \"./bucket\";\nimport * as EdgeCollisionAABB from './edge-collision-aabb';\n\nconst qs = new URLSearchParams(window.location.search);\nconst demoName = qs.get(\"demo\");\n\nconst demos = new Map<string, { start: () => void; stop?: () => void }>([\n  [\"Bucket of Circles (Verlet)\", Bucket],\n  [\"Circle Collisions (Verlet)\", CircleCollisions],\n  [\"Circle to Box Collision (Verlet)\", CircleBoxCollision],\n  [\"Single Edge Collision (Verlet)\", EdgeCollision],\n  [\"Platformer (AABB Impulse Model)\", Platformer],\n  [\"AABB Overlap Demo (AABB Impulse Model)\", AABBOverlapDemo],\n  [\"AABB Soup Demo (AABB Impulse Model)\", AABBSoupDemo],\n  [\"Single Edge Collision (AABB Impulse Model)\", EdgeCollisionAABB]\n]);\n\nif (demoName && demos.has(demoName)) {\n  demos.get(demoName)!.start();\n} else {\n  const names = Array.from(demos.keys());\n\n  const li = (name: string) => {\n    const cmp = encodeURIComponent(name);\n    const url = `${window.location.pathname}?demo=${cmp}`;\n    return `\n      <li><a href=\"${url}\">${name}</a></li>\n    `;\n  };\n\n  const html = `\n    <ul>\n      ${names.map(name => li(name)).join(\"\\n\")}\n    </ul>\n  `;\n  const el = document.createElement(\"div\");\n  el.innerHTML = html;\n  document.body.appendChild(el);\n}\n"]}