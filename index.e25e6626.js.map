{"mappings":"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","sources":["src/v2.ts","node_modules/science-halt/index.js","src/accelerate.ts","src/collide-circle-circle.ts","src/collide-circle-edge.ts","src/collision-response-aabb.ts","src/solve-distance-constraint.ts","src/solve-drag.ts","src/solve-gravitation.ts","src/inertia.ts","src/overlap-aabb-aabb.ts","src/overlap-circle-circle.ts","src/segment-intersection.ts","src/rewind-to-collision-point.ts","src/project-point-edge.ts","src/project-capsule.ts","examples/aabb-overlap.ts","examples/aabb-soup.ts","examples/circle-collisions.ts","examples/circle-box-collision.ts","examples/edge-collision.ts","examples/platformer.ts","examples/bucket.ts","examples/edge-collision-aabb.ts","examples/index.ts"],"sourcesContent":["export type Vector2<V extends number = number> = { x: V; y: V; };\n\nexport function v2<V extends number> (x?: V, y?: V): Vector2<V> {\n  return { x: x || 0 as V, y: y || 0 as V}\n}\n\nexport const copy = (out: Vector2, a: Vector2) => {\n  out.x = a.x;\n  out.y = a.y;\n  return out;\n}\n\nexport const set = <V extends number>(out: Vector2<V>, x: V, y: V) => {\n  out.x = x;\n  out.y = y;\n  return out;\n}\n\nexport const add = <V extends number>(out: Vector2<V>, a: Vector2<V>, b: Vector2<V>) => {\n  out.x = a.x + b.x as V;\n  out.y = a.y + b.y as V;\n  return out;\n}\n\nexport const sub = <V extends number>(out: Vector2<V>, a: Vector2<V>, b: Vector2<V>) => {\n  out.x = a.x - b.x as V;\n  out.y = a.y - b.y as V;\n  return out;\n}\n\nexport const dot = <V extends number>(a: Vector2<V>, b: Vector2<V>) => a.x * b.x + a.y * b.y\n\nexport const scale = <V extends number>(out: Vector2<V>, a: Vector2<V>, factor: number) => {\n  out.x = a.x * factor as V;\n  out.y = a.y * factor as V;\n  return out;\n}\n\nexport const distance = <V extends number>(v1: Vector2<V>, v2: Vector2<V>) => {\n  const x = v1.x - v2.x;\n  const y = v1.y - v2.y;\n  return Math.sqrt(x*x + y*y);\n}\n\nexport const distance2 = <V extends number>(v1: Vector2<V>, v2: Vector2<V>) => {\n  const x = v1.x - v2.x;\n  const y = v1.y - v2.y;\n  return x*x + y*y;\n}\n\nexport const magnitude = <V extends number>(v1: Vector2<V>) => {\n  const x = v1.x;\n  const y = v1.y;\n  return Math.sqrt(x*x + y*y);\n}\n\nexport const normalize = <V extends number>(out: Vector2<V>, a: Vector2<V>) => {\n  const x = a.x;\n  const y = a.y;\n  let len = x*x + y*y;\n  if (len > 0) {\n    len = 1 / Math.sqrt(len);\n    out.x = a.x * len as V;\n    out.y = a.y * len as V;\n  }\n  return out;\n}\n\n/**\n * Compute the normal pointing away perpendicular from two vectors.\n * Given v1(0,0) -> v2(10, 0), the normal will be (0, 1)\n * */\nexport const normal = <V extends number>(out: Vector2<V>, v1: Vector2<V>, v2: Vector2<V>) => {\n  out.y = v2.x - v1.x as V;\n  out.x = v1.y - v2.y as V;\n  return normalize(out, out);\n}\n\n// the perpendicular dot product, also known as \"cross\" elsewhere\n// http://stackoverflow.com/a/243977/169491\nexport const perpDot = <V extends number>(v1: Vector2<V>, v2: Vector2<V>) => {\n  return v1.x * v2.y - v1.y * v2.x;\n}\n\n/**\n * This is mostly useful for moving a verlet-style [current, previous]\n * by the same amount, translating them while preserving velocity.\n * @param by the vector to add to each subsequent vector\n * @param vN any number of vectors to translate\n */\nexport const translate = <V extends number>(by: Vector2<V>, ...vN: Vector2<V>[]) => {\n  for (let i = 0; i < vN.length; i++) {\n    const v = vN[i];\n    add(v, v, by);\n  }\n}\n\n/**\n * \n * @param v Print this vector for nice logs\n */\nexport function vd(v: Vector2) {\n  return `(${v.x}, ${v.y})`;\n}\n\n/**\n * Rotate a vector around another point. Taken nearly verbatim from gl-matrix\n */\nexport const rotate2d = <V extends Vector2>(\n  out: V,\n  target: V,\n  origin: V,\n  rad: number\n) => {\n  //Translate point to the origin\n  const p0 = target.x - origin.x;\n  const p1 = target.y - origin.y;\n  const sinC = Math.sin(rad);\n  const cosC = Math.cos(rad);\n\n  //perform rotation and translate to correct position\n  out.x = p0 * cosC - p1 * sinC + origin.x;\n  out.y = p0 * sinC + p1 * cosC + origin.y;\n\n  return out;\n}\n\n/**\n * Compute the Theta angle between a vector and the origin.\n */\nexport function angleOf(v: Vector2) {\n  return Math.atan2(v.y, v.x);\n}","\nmodule.exports = function(onhalt, opt_msg, opt_keycode) {\n  document.addEventListener('keydown', function(e) {\n    if (e.which == (opt_keycode || 27)) {\n      onhalt();\n      console.log(opt_msg || 'HALT IN THE NAME OF SCIENCE!');\n    }\n  })\n}","import { set } from './v2';\nimport { DeltaTimeMS, Integratable } from './common-types';\n\nexport const accelerate = (cmp: Integratable, dt: DeltaTimeMS) => {\n  // apply acceleration to current position, convert dt to seconds\n  cmp.cpos.x += cmp.acel.x * dt * dt * 0.001;\n  cmp.cpos.y += cmp.acel.y * dt * dt * 0.001;\n\n  // reset acceleration\n  set(cmp.acel, 0, 0);\n};","import { add, distance2, set, sub } from \"./v2\";\nimport { VelocityDerivable } from \"./common-types\";\n\n// Preallocations!\nconst vel1 = { x: 0, y: 0 };\nconst vel2 = { x: 0, y: 0 };\nconst diff = { x: 0, y: 0 };\nconst move = { x: 0, y: 0 };\n\n// TODO: is the below even true???\n// The codeflow demo does nothing if the circles are no longer overlapping.\n\n// It's very important that this function not do any distance checking.\n// It is assumed that if this function is called, then the points are\n// definitely colliding, and that after being called with preserveInertia\n// === false, another call with === true should be made, even if the first\n// calculation has moved the points away from physically touching.\n\nexport const collideCircleCircle = (\n  p1: VelocityDerivable,\n  p1radius: number,\n  p1mass: number,\n  p2: VelocityDerivable,\n  p2radius: number,\n  p2mass: number,\n  preserveInertia: boolean,\n  damping: number\n) => {\n  const dist2 = distance2(p1.cpos, p2.cpos);\n  const target = p1radius + p2radius;\n  const min2 = target * target;\n\n  // if (dist2 > min2) return;\n\n  sub(vel1, p1.cpos, p1.ppos);\n  sub(vel2, p2.cpos, p2.ppos);\n\n  sub(diff, p1.cpos, p2.cpos);\n  const dist = Math.sqrt(dist2);\n  let factor = (dist - target) / dist;\n\n  // Avoid division by zero in case points are directly atop each other.\n  if (dist === 0) factor = 1;\n\n  const mass1 = p1mass > 0 ? p1mass : 1;\n  const mass2 = p2mass > 0 ? p2mass : 1;\n  const massT = mass1 + mass2;\n\n  // Move a away\n  move.x = diff.x * factor * (mass2 / massT);\n  move.y = diff.y * factor * (mass2 / massT);\n  if (p1mass > 0) {\n    sub(p1.cpos, p1.cpos, move);\n  }\n\n  // Move b away\n  move.x = diff.x * factor * (mass1 / massT);\n  move.y = diff.y * factor * (mass1 / massT);\n  if (p2mass > 0) {\n    add(p2.cpos, p2.cpos, move);\n  }\n\n  if (!preserveInertia) return;\n\n  damping = damping || 1;\n\n  const f1 = (damping * (diff.x * vel1.x + diff.y * vel1.y)) / (dist2 || 1);\n  const f2 = (damping * (diff.x * vel2.x + diff.y * vel2.y)) / (dist2 || 1);\n\n  vel1.x += (f2 * diff.x - f1 * diff.x) / (mass1 || 1); // * (mass2 / massT);\n  vel2.x += (f1 * diff.x - f2 * diff.x) / (mass2 || 1); // * (mass1 / massT);\n  vel1.y += (f2 * diff.y - f1 * diff.y) / (mass1 || 1); // * (mass2 / massT);\n  vel2.y += (f1 * diff.y - f2 * diff.y) / (mass2 || 1); // * (mass1 / massT);\n\n  if (p1mass > 0) set(p1.ppos, p1.cpos.x - vel1.x, p1.cpos.y - vel1.y);\n  if (p2mass > 0) set(p2.ppos, p2.cpos.x - vel2.x, p2.cpos.y - vel2.y);\n};\n","import {\n  add,\n  distance2,\n  set,\n  sub,\n  v2,\n  dot,\n  scale,\n  distance,\n  copy,\n  normalize,\n  Vector2\n} from \"./v2\";\nimport { collideCircleCircle } from \"./collide-circle-circle\";\nimport { VelocityDerivable } from \"./common-types\";\n\n// Preallocations\nconst edgeDir = v2();\nconst edge = v2();\nconst prevEdge = v2();\nconst hypo = v2();\nconst epDiff = v2();\nconst correction = v2();\nconst collisionPoint = v2();\nconst tunnelPoint = v2();\n\nconst ep = {\n  cpos: v2(),\n  ppos: v2()\n};\n\nconst epBefore = {\n  cpos: v2(),\n  ppos: v2()\n};\n\nexport function collideCircleEdge(\n  circle: VelocityDerivable,\n  radius3: number,\n  mass3: number,\n  endpoint1: VelocityDerivable,\n  mass1: number,\n  endpoint2: VelocityDerivable,\n  mass2: number,\n  preserveInertia: boolean,\n  damping: number\n) {\n  // Edge direction (edge in local space)\n  sub(edge, endpoint2.cpos, endpoint1.cpos);\n\n  // Normalize collision edge (assume collision axis is edge)\n  normalize(edgeDir, edge);\n\n  // Vector from endpoint1 to particle\n  sub(hypo, circle.cpos, endpoint1.cpos);\n\n  // Where is the particle on the edge, before, after, or on?\n  // Also used for interpolation later.\n  const projection = dot(edge, hypo);\n  const maxDot = dot(edge, edge);\n  const edgeMag = Math.sqrt(maxDot);\n\n  // Colliding beyond the edge...\n  if (projection < 0 || projection > maxDot) return;\n\n  // Create interpolation factor of where point closest\n  // to particle is on the line.\n  const t = projection / maxDot;\n  const u = 1 - t;\n\n  // Find the point of collision on the edge.\n  scale(collisionPoint, edgeDir, t * edgeMag);\n  add(collisionPoint, collisionPoint, endpoint1.cpos);\n  const dist = distance(collisionPoint, circle.cpos);\n\n  // Bail if point and edge are too far apart.\n  if (dist > radius3) return;\n\n  // Distribute mass of colliding point into two fake points\n  // and use those to collide against each endpoint independently.\n\n  const standinMass1 = u * mass3;\n  const standinMass2 = t * mass3;\n\n  const standin1 = {\n    cpos: v2(),\n    ppos: v2()\n  };\n\n  const standin2 = {\n    cpos: v2(),\n    ppos: v2()\n  };\n\n  // Slide standin1 along edge to be in front of endpoint1\n  scale(standin1.cpos, edgeDir, t * edgeMag);\n  sub(standin1.cpos, circle.cpos, standin1.cpos);\n  scale(standin1.ppos, edgeDir, t * edgeMag);\n  sub(standin1.ppos, circle.ppos, standin1.ppos);\n\n  // Slide standin2 along edge to be in front of endpoint2\n  scale(standin2.cpos, edgeDir, u * edgeMag);\n  add(standin2.cpos, circle.cpos, standin2.cpos);\n  scale(standin2.ppos, edgeDir, u * edgeMag);\n  add(standin2.ppos, circle.ppos, standin2.ppos);\n\n  const standin1Before = {\n    cpos: v2(),\n    ppos: v2()\n  };\n\n  const standin2Before = {\n    cpos: v2(),\n    ppos: v2()\n  };\n\n  // Stash state of standins\n  copy(standin1Before.cpos, standin1.cpos);\n  copy(standin1Before.ppos, standin1.ppos);\n  copy(standin2Before.cpos, standin2.cpos);\n  copy(standin2Before.ppos, standin2.ppos);\n\n  const edgeRadius = 0;\n\n  // Collide standins with endpoints\n  collideCircleCircle(\n    standin1,\n    radius3,\n    standinMass1,\n    endpoint1,\n    edgeRadius,\n    mass1,\n    preserveInertia,\n    damping\n  );\n\n  collideCircleCircle(\n    standin2,\n    radius3,\n    standinMass2,\n    endpoint2,\n    edgeRadius,\n    mass2,\n    preserveInertia,\n    damping\n  );\n\n  const standin1Delta = {\n    cpos: v2(),\n    ppos: v2()\n  };\n\n  const standin2Delta = {\n    cpos: v2(),\n    ppos: v2()\n  };\n\n  // Compute standin1 cpos change\n  sub(standin1Delta.cpos, standin1.cpos, standin1Before.cpos);\n\n  // Compute standin2 cpos change\n  sub(standin2Delta.cpos, standin2.cpos, standin2Before.cpos);\n\n  scale(standin1Delta.cpos, standin1Delta.cpos, u);\n  scale(standin2Delta.cpos, standin2Delta.cpos, t);\n\n  // Apply cpos changes to point3\n  add(circle.cpos, circle.cpos, standin1Delta.cpos);\n  add(circle.cpos, circle.cpos, standin2Delta.cpos);\n\n  if (!preserveInertia) return;\n\n  // TODO: instead of adding diff, get magnitude of diff and scale\n  // in reverse direction of standin velocity from point3.cpos because\n  // that is what circlecircle does.\n\n  // Compute standin1 ppos change\n  sub(standin1Delta.ppos, standin1.ppos, standin1Before.ppos);\n\n  // Compute standin2 ppos change\n  sub(standin2Delta.ppos, standin2.ppos, standin2Before.ppos);\n\n  scale(standin1Delta.ppos, standin1Delta.ppos, u);\n  scale(standin2Delta.ppos, standin2Delta.ppos, t);\n\n  // Apply ppos changes to point3\n  add(circle.ppos, circle.ppos, standin1Delta.ppos);\n  add(circle.ppos, circle.ppos, standin2Delta.ppos);\n}\n\ntype Particle = {\n  mass: number;\n  radius: number;\n} & VelocityDerivable;\n\nfunction snapshotDebug(\n  name: string,\n  particles: Particle[] = [],\n  points: [string, Vector2][] = []\n) {\n  const cvs = document.createElement(\"canvas\");\n  const ctx = cvs.getContext(\"2d\")!;\n  document.body.appendChild(cvs);\n  // let minX = Number.MAX_SAFE_INTEGER;\n  // let maxX = Number.MIN_SAFE_INTEGER;\n  // let minY = Number.MAX_SAFE_INTEGER;\n  // let maxY = Number.MIN_SAFE_INTEGER;\n  // for (let i = 0; i < particles.length; i++) {\n  //   const particle = particles[i];\n  //   minX = Math.min(\n  //     minX,\n  //     particle.cpos.x - particle.radius,\n  //     particle.ppos.x - particle.radius\n  //   );\n  //   maxX = Math.max(\n  //     maxX,\n  //     particle.cpos.x + particle.radius,\n  //     particle.ppos.x + particle.radius\n  //   );\n  //   minY = Math.min(\n  //     minY,\n  //     particle.cpos.y - particle.radius,\n  //     particle.ppos.y - particle.radius\n  //   );\n  //   maxY = Math.max(\n  //     maxY,\n  //     particle.cpos.y + particle.radius,\n  //     particle.ppos.y + particle.radius\n  //   );\n  // }\n\n  // for (let i = 0; i < points.length; i++) {\n  //   const [, point] = points[i];\n  //   minX = Math.min(minX, point.x, point.x);\n  //   maxX = Math.max(maxX, point.x, point.x);\n  //   minY = Math.min(minY, point.y, point.y);\n  //   maxY = Math.max(maxY, point.y, point.y);\n  // }\n\n  // cvs.width = maxX - minX;\n  // cvs.height = maxY - minY;\n\n  // ctx.translate(-minX, -minY);\n\n  cvs.width = 800;\n  cvs.height = 800;\n\n  for (let i = 0; i < particles.length; i++) {\n    const particle = particles[i];\n    ctx.fillStyle = \"rgba(255, 0, 0, 0.5)\";\n    ctx.beginPath();\n    ctx.arc(\n      particle.ppos.x,\n      particle.ppos.y,\n      particle.radius,\n      0,\n      Math.PI * 2,\n      false\n    );\n    ctx.fill();\n\n    ctx.fillStyle = \"rgba(0, 0, 0, 0.5)\";\n    ctx.beginPath();\n    ctx.arc(\n      particle.cpos.x,\n      particle.cpos.y,\n      particle.radius,\n      0,\n      Math.PI * 2,\n      false\n    );\n    ctx.fill();\n  }\n\n  for (let i = 0; i < points.length; i++) {\n    const [name, point] = points[i];\n    ctx.fillStyle = \"purple\";\n    ctx.fillRect(point.x, point.y, 1, 1);\n    ctx.fillText(`${name} (${point.x},${point.y})`, point.x + 1, point.y + 1);\n  }\n\n  // ctx.translate(minX, minY);\n  ctx.fillStyle = \"black\";\n  ctx.fillText(name, 10, 10);\n}\n","import {\n  add,\n  dot,\n  magnitude,\n  normalize,\n  scale,\n  set,\n  copy,\n  sub,\n  v2,\n  Vector2\n} from \"./v2\";\n\n// Registers / Preallocations\n\nconst basis = v2();\nconst basisNeg = v2();\n\nconst vel1 = v2();\nconst vel1x = v2();\nconst vel1y = v2();\n\nconst vel2 = v2();\nconst vel2x = v2();\nconst vel2y = v2();\n\nconst newVel1 = v2();\nconst newVel2 = v2();\n\nconst t1 = v2();\nconst t2 = v2();\n\nconst u1 = v2();\nconst u2 = v2();\n\n// TODO: Put this somewhere...\nconst EPSILON = 0.0001;\n\n// TODO: change this API to accept numbers (x, y) instead of vectors\n\n// friction calc: sqrt(friction1*friction2)\n// restitution: box2d: https://github.com/erincatto/Box2D/blob/6a69ddbbd59b21c0d6699c43143b4114f7f92e21/Box2D/Box2D/Dynamics/Contacts/b2Contact.h#L42-L47\n// Math.max(restitution1, restitution2);\n\n/**\n * Really should be called collisionResponseImpulse, as it has nothing to do\n * with the shape of the bodies colliding. It's just two points with mass and\n * friction.\n * @param cpos1 \n * @param ppos1 \n * @param mass1 \n * @param restitution1 1 == perfectly elastic collision, 0 == all energy is\n * killed.\n * @param staticFriction1 How much friction must be overcome before the object\n * will start moving. 0 == no friction, 1 == max friction. Set this higher, like\n * 0.9.\n * @param dynamicFriction1 How much constant friction occurs when the object is\n * already in motion. 0 == no friction, 1 == max friction. Better to set this\n * low, like 0.1.\n * @param cpos2 \n * @param ppos2 \n * @param mass2 \n * @param restitution2 1 == perfectly elastic collision, 0 == all energy is\n * killed.\n * @param staticFriction2 How much friction must be overcome before the object\n * will start moving. 0 == no friction, 1 == max friction. Set this higher, like\n * 0.9.\n * @param dynamicFriction2 How much constant friction occurs when the object is\n * already in motion. 0 == no friction, 1 == max friction. Better to set this\n * low, like 0.1.\n * @param collisionNormal The vector defining the relative axis of collision.\n * Leaving this as 0,0 will compute it as the midpoint between positions of the\n * two colliding objects (modeling a circular collision). If colliding with a\n * known edge or line segment, it's best to provide the edge normal as this\n * value.\n * @param vel1out The new velocity resulting from reacting to this collison.\n * cpos1 - this value == new ppos1.\n * @param vel2out The new velocity resulting from reacting to this collison.\n * cpos2 - this value == new ppos2.\n */\nexport const collisionResponseAABB = (\n  cpos1: Vector2,\n  ppos1: Vector2,\n  mass1: number,\n  restitution1: number,\n  staticFriction1: number,\n  dynamicFriction1: number,\n  cpos2: Vector2,\n  ppos2: Vector2,\n  mass2: number,\n  restitution2: number,\n  staticFriction2: number,\n  dynamicFriction2: number,\n  collisionNormal: Vector2,\n  vel1out: Vector2,\n  vel2out: Vector2\n) => {\n  // blank out all preallocated vectors.\n  set(basis, 0, 0);\n  set(basisNeg, 0, 0);\n  set(vel1, 0, 0);\n  set(vel1x, 0, 0);\n  set(vel1y, 0, 0);\n  set(vel2, 0, 0);\n  set(vel2x, 0, 0);\n  set(vel2y, 0, 0);\n  set(newVel1, 0, 0);\n  set(newVel2, 0, 0);\n  set(t1, 0, 0);\n  set(t2, 0, 0);\n  set(u1, 0, 0);\n  set(u2, 0, 0);\n\n  // If collisionNormal is provided, use it. Otherwise, use midpoint between\n  // current positions as axis of collision. Midpoint will model a circular\n  // collision if used.\n  if (collisionNormal && (collisionNormal.x !== 0 || collisionNormal.y !== 0)) {\n    set(basis, collisionNormal.x, collisionNormal.y);\n  } else {\n    sub(basis, cpos1, cpos2);\n    normalize(basis, basis);\n  }\n\n  scale(basisNeg, basis, -1);\n\n  //const friction;\n  // Take max of restitutions, like box2d does.\n  // https://github.com/erincatto/Box2D/blob/6a69ddbbd59b21c0d6699c43143b4114f7f92e21/Box2D/Box2D/Dynamics/Contacts/b2Contact.h#L42-L47\n  // \"for example, a superball bounces on everything\"\n  const restitution = restitution1 > restitution2 ? restitution1 : restitution2;\n  const massTotal = mass1 + mass2;\n  const e = 1 + restitution;\n\n  // I = (1+e)*N*(Vr  N) / (1/Ma + 1/Mb)\n  // Va -= I * 1/Ma\n  // Vb += I * 1/Mb\n  //sub(vel1, cpos1, ppos1);\n  //sub(vel2, cpos2, ppos2);\n  //const relativeVelocity = sub(vel1, vel2);\n  //const I = v2();\n  //scale(I, normal, (1 + restitution) * dot(relativeVelocity, normal));\n  //scale(I, I, 1 / (1/mass1 + 1/mass2));\n\n  // \"x\" and \"y\" in the following sections are shorthand for:\n  // x: component of the box velocity parallel to the collision normal\n  // y: the rest of the collision velocity\n\n  // calculate x-direction velocity vector and perpendicular y-vector for box 1\n  sub(vel1, cpos1, ppos1);\n  const x1 = dot(basis, vel1);\n  scale(vel1x, basis, x1);\n  sub(vel1y, vel1, vel1x);\n\n  // calculate x-direction velocity vector and perpendicular y-vector for box 2\n  sub(vel2, cpos2, ppos2);\n  const x2 = dot(basisNeg, vel2);\n  scale(vel2x, basisNeg, x2);\n  sub(vel2y, vel2, vel2x);\n\n  // equations of motion for box1\n  scale(t1, vel1x, (mass1 - mass2) / massTotal);\n  scale(t2, vel2x, (e * mass2) / massTotal);\n  add(newVel1, t1, t2);\n  add(newVel1, newVel1, vel1y);\n\n  // equations of motion for box2\n  scale(u1, vel1x, (e * mass1) / massTotal);\n  scale(u2, vel2x, (mass2 - mass1) / massTotal);\n  add(newVel2, u1, u2);\n  add(newVel2, newVel2, vel2y);\n\n  // new relative velocity\n  const rv = add(v2(), newVel1, newVel2);\n\n  // tangent to relative velocity vector\n  const reg1 = v2();\n  scale(reg1, basis, dot(rv, basis));\n  const tangent = sub(v2(), rv, reg1);\n  normalize(tangent, tangent);\n\n  // magnitude of relative velocity in tangent direction\n  let jt = -dot(rv, tangent);\n  jt /= 1 / (mass1 + mass2); // not sure about this...\n  // https://github.com/RandyGaul/ImpulseEngine/blob/d12af9c95555244a37dce1c7a73e60d5177df652/Manifold.cpp#L103\n\n  const jtMag = Math.abs(jt);\n\n  // only apply significant friction\n  if (jtMag > EPSILON) {\n    // magnitudes of velocity along the collision tangent, hopefully.\n    const vel1ymag = magnitude(vel1y);\n    const vel2ymag = magnitude(vel2y);\n\n    // compute Coulumb's law (choosing dynamic vs static friction)\n    const frictionImpulse1 = v2();\n    const frictionImpulse2 = v2();\n\n    // TODO: may need to use Math.max(Math.abs(vel1ymag, vel2ymag)) when\n    // choosing to incorporate velocity magnitude into the friction calc.\n    // A stationary box getting hit currently receives perfect energy\n    // transfer, since its vel2ymag is 0.\n\n    if (jtMag < vel1ymag * staticFriction1) {\n      scale(frictionImpulse1, tangent, staticFriction1);\n    } else {\n      scale(frictionImpulse1, tangent, -vel1ymag * dynamicFriction1);\n    }\n\n    if (jtMag < vel2ymag * staticFriction2) {\n      scale(frictionImpulse2, tangent, staticFriction2);\n    } else {\n      scale(frictionImpulse2, tangent, -vel2ymag * dynamicFriction2);\n    }\n\n    add(newVel1, newVel1, frictionImpulse1);\n    add(newVel2, newVel2, frictionImpulse2);\n  }\n\n  // output new velocity of box1 and box2\n  copy(vel1out, newVel1);\n  copy(vel2out, newVel2);\n};\n","import { add, distance2, set, sub, v2, magnitude, scale } from \"./v2\";\nimport { Integratable } from \"./common-types\";\n\n// negative or zero mass implies a fixed or \"pinned\" point\nexport function solveDistanceConstraint(\n  p1: Integratable,\n  p1mass: number,\n  p2: Integratable,\n  p2mass: number,\n  goal: number,\n  // number between 0 and 1\n  stiffness = 1,\n  // If false, correct the previous position in addition to the current position\n  // when solving the constraint. While unnatural looking, this will prevent\n  // \"energy\" (velocity) from being spontaneously created in the constraint\n  // system.\n  impartEnergy = true\n): void {\n  const mass1 = p1mass > 0 ? p1mass : 1;\n  const mass2 = p2mass > 0 ? p2mass : 1;\n  const imass1 = 1 / (mass1 || 1);\n  const imass2 = 1 / (mass2 || 1);\n  const imass = imass1 + imass2;\n\n  // Current relative vector\n  const delta = sub(v2(), p2.cpos, p1.cpos);\n  const deltaMag = magnitude(delta);\n\n  // nothing to do.\n  if (deltaMag === 0) return;\n\n  // Difference between current distance and goal distance\n  const diff = (deltaMag - goal) / deltaMag;\n\n  // TODO: is this even correct? Should mass come into effect here?\n  // approximate mass\n  scale(delta, delta, diff / imass);\n\n  // TODO: not sure if this is the right place to apply stiffness.\n  const p1correction = scale(v2(), delta, imass1 * stiffness);\n  const p2correction = scale(v2(), delta, imass2 * stiffness);\n\n  // Add correction to p1, but only if not \"pinned\".\n  // If it's pinned and p2 is not, apply it to p2.\n  if (p1mass > 0) {\n    add(p1.cpos, p1.cpos, p1correction);\n    if (!impartEnergy) add(p1.ppos, p1.ppos, p1correction);\n  } else if (p2mass > 0) {\n    sub(p2.cpos, p2.cpos, p1correction);\n    if (!impartEnergy) sub(p2.ppos, p2.ppos, p1correction);\n  }\n\n  // Add correction to p2, but only if not \"pinned\".\n  // If it's pinned and p1 is not, apply it to p1.\n  if (p2mass > 0) {\n    sub(p2.cpos, p2.cpos, p2correction);\n    if (!impartEnergy) sub(p2.ppos, p2.ppos, p2correction);\n  } else if (p1mass > 0) {\n    add(p1.cpos, p1.cpos, p2correction);\n    if (!impartEnergy) add(p1.ppos, p1.ppos, p2correction);\n  }\n}\n","import { VelocityDerivable } from \"./common-types\";\n\nexport const solveDrag = (p1: VelocityDerivable, drag: number) => {\n  const x = (p1.ppos.x - p1.cpos.x) * drag;\n  const y = (p1.ppos.y - p1.cpos.y) * drag;\n  p1.ppos.x = p1.cpos.x + x;\n  p1.ppos.y = p1.cpos.y + y;\n};","import { add, magnitude, normalize, scale, set, v2 } from \"./v2\";\nimport { Integratable, VelocityDerivable } from \"./common-types\";\nconst accel1 = v2();\n\nexport function solveGravitation(\n  p1: Integratable,\n  p1mass: number,\n  p2: VelocityDerivable,\n  p2mass: number,\n  gravityConstant = 0.99\n) {\n  // handle either obj not having mass\n  if (p1mass <= 0 || p2mass <= 0) return;\n\n  let mag: number;\n  let factor: number;\n\n  const diffx = p2.cpos.x - p1.cpos.x;\n  const diffy = p2.cpos.y - p1.cpos.y;\n\n  set(accel1, diffx, diffy);\n  mag = magnitude(accel1);\n\n  // Prevent divide by zero.\n  mag = mag === 0 ? 1 : mag;\n\n  // Newton's Law of Universal Gravitation -- Vector Form!\n  factor = gravityConstant * ((p1mass * p2mass) / (mag * mag));\n\n  // scale by gravity acceleration\n  normalize(accel1, accel1);\n  scale(accel1, accel1, factor);\n\n  // add the acceleration from gravity to p1 accel\n  add(p1.acel, p1.acel, accel1);\n}\n","import { set } from \"./v2\";\nimport { Integratable } from \"./common-types\";\n\nexport const inertia = (cmp: Integratable) => {\n  const x = cmp.cpos.x * 2 - cmp.ppos.x;\n  const y = cmp.cpos.y * 2 - cmp.ppos.y;\n\n  set(cmp.ppos, cmp.cpos.x, cmp.cpos.y);\n  set(cmp.cpos, x, y);\n};\n","import { set, Vector2, normalize, v2 } from \"./v2\";\n\n// https://github.com/noonat/intersect/blob/master/intersect.js\n\nexport type AABBOverlapResult = {\n  resolve: Vector2;\n  hitPos: Vector2;\n  normal: Vector2;\n};\n\n/**\n * Create a result object to use for overlap tests.\n */\nexport const createAABBOverlapResult = () => {\n  return { resolve: v2(), hitPos: v2(), normal: v2() };\n};\n\n/**\n * Compute the \"collision manifold\" for two AABB, storing the result in `result`.\n * Note: The `normal` is always perpendicular to an AABB edge, which may produce\n * some slighly weird-looking collisions. `collisionResponseAABB()` will compute\n * a normal using the midpoints, which looks more natural.\n */\nexport const overlapAABBAABB = (\n  center1X: number,\n  center1Y: number,\n  width1: number,\n  height1: number,\n  center2X: number,\n  center2Y: number,\n  width2: number,\n  height2: number,\n  result: AABBOverlapResult\n) => {\n  const dx = center2X - center1X;\n  const px = width2 / 2 + width1 / 2 - Math.abs(dx);\n  const dy = center2Y - center1Y;\n  const py = height2 / 2 + height1 / 2 - Math.abs(dy);\n\n  if (px <= 0) return null;\n  if (py <= 0) return null;\n\n  set(result.resolve, 0, 0);\n  set(result.hitPos, 0, 0);\n  set(result.normal, 0, 0);\n\n  if (px < py) {\n    const sx = dx < 0 ? -1 : 1;\n    result.resolve.x = px * sx;\n    result.normal.x = sx;\n    // Really not sure about these values.\n    result.hitPos.x = center1X + (width1 / 2) * sx;\n    result.hitPos.y = center2Y;\n  } else {\n    const sy = dy < 0 ? -1 : 1;\n    result.resolve.y = py * sy;\n    result.normal.y = sy;\n    // Really not sure about these values.\n    result.hitPos.x = center2X;\n    result.hitPos.y = center1Y + (height1 / 2) * sy;\n  }\n\n  return result;\n};\n","export const overlapCircleCircle = (\n  ax: number,\n  ay: number,\n  arad: number,\n  bx: number,\n  by: number,\n  brad: number\n) => {\n  const x = bx - ax;\n  const y = by - ay;\n  const rad = arad + brad;\n  return x * x + y * y < rad * rad;\n};\n","import { sub, v2, Vector2 } from \"./v2\";\n\nconst s1 = v2();\nconst s2 = v2();\n\nexport function segmentIntersection(\n  p0: Vector2,\n  p1: Vector2,\n  p2: Vector2,\n  p3: Vector2,\n  intersectionPoint: Vector2\n) {\n  sub(s1, p1, p0);\n  sub(s2, p3, p2);\n\n  const s =\n    (-s1.y * (p0.x - p2.x) + s1.x * (p0.y - p2.y)) /\n    (-s2.x * s1.y + s1.x * s2.y);\n  const t =\n    (s2.x * (p0.y - p2.y) - s2.y * (p0.x - p2.x)) /\n    (-s2.x * s1.y + s1.x * s2.y);\n\n  if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {\n    // Collision detected\n    intersectionPoint.x = p0.x + t * s1.x;\n    intersectionPoint.y = p0.y + t * s1.y;\n    return true;\n  }\n\n  return false;\n}\n","import { sub, v2, Vector2, scale, normalize, add } from \"./v2\";\nimport { segmentIntersection } from \"./segment-intersection\";\nimport { Integratable } from \"./common-types\";\n\nconst tunnelPoint = v2();\nconst offset = v2();\n\nconst v = v2();\nconst direction = v2();\nconst radiusSegment = v2();\nconst cposIncludingRadius = v2();\n\nexport function rewindToCollisionPoint(\n  point3: Integratable,\n  radius3: number,\n  point1: Vector2,\n  point2: Vector2\n): boolean {\n  // detect if a collision has occurred but would have been missed due to\n  // point3 moving beyond the edge in one time step.\n  \n  // TODO: this should accept some sort of manifold or collision contact object,\n  // not randum args (radius, etc). Without a manifold it's imposible to know \n  // if the point \"tunneled\" due to a collision or the result of _resolving_\n  // a collision!\n\n  // Compute where the cpos would be if the segment actually included the\n  // radius.\n  // Without this, we would rewind to the point3 center, and the direction\n  // of two points colliding with each other exactly is undefined.\n  sub(v, point3.cpos, point3.ppos);\n  normalize(direction, v);\n  scale(radiusSegment, direction, radius3);\n  add(cposIncludingRadius, radiusSegment, point3.cpos);\n\n  const hasTunneled = segmentIntersection(\n    cposIncludingRadius,\n    point3.ppos,\n    point1,\n    point2,\n    tunnelPoint\n  );\n\n  if (!hasTunneled) return false;\n\n  // Translate point3 to tunnelPoint, including the radius of the point.\n  sub(offset, cposIncludingRadius, tunnelPoint);\n  \n  sub(point3.cpos, point3.cpos, offset);\n  sub(point3.ppos, point3.ppos, offset);\n  return true;\n}\n\nfunction debuggerIfNaN(point: Vector2) {\n  if (isNaN(point.x) || isNaN(point.y)) {\n    debugger;\n  }\n}\n","import {\n  Vector2,\n  sub,\n  v2,\n  normal,\n  dot,\n  distance,\n  set,\n} from \"./v2\";\n\nexport type PointEdgeProjection = {\n  // distance between the point and the projected point on the line\n  distance: number;\n  // dot product between edge normal (perp of endpoint1 -> endpoint2) and normal\n  // from edge to point. If positive, they are pointing in the same direction\n  // (aka the point is on the side of the segment in the direction of the\n  // normal). If negative, the point is on the opposite side. The absolute value\n  // of this will always match the distance.\n  similarity: number;\n  // What percentage along the line the projection is. < 0 means behind the\n  // edge, > 1 means ahead of the edge endpoints.\n  u: number;\n  // The point in absolute space of the projection along the edge\n  projectedPoint: Vector2;\n  // The normal of the edge (endpoint1 -> endpoint2): Given v1(0,0) -> v2(10, 0), the normal will be (0, 1)\n  edgeNormal: Vector2;\n};\n\n/**\n * Create a pre-made result object for tests.\n */\nexport function createPointEdgeProjectionResult(): PointEdgeProjection {\n  return {\n    distance: 0,\n    similarity: 0,\n    u: 0,\n    projectedPoint: v2(),\n    edgeNormal: v2(),\n  };\n}\n\nconst edgeDelta = v2();\nconst perp = v2();\n\nexport function projectPointEdge(\n  point: Vector2,\n  endpoint1: Vector2,\n  endpoint2: Vector2,\n  result: PointEdgeProjection\n) {\n  sub(edgeDelta, endpoint2, endpoint1);\n  if (edgeDelta.x === 0 && edgeDelta.y === 0) {\n    throw new Error('ZeroLengthEdge');\n  }\n\n  // http://paulbourke.net/geometry/pointlineplane/\n  // http://paulbourke.net/geometry/pointlineplane/DistancePoint.java\n  const u =\n    ((point.x - endpoint1.x) * edgeDelta.x + (point.y - endpoint1.y) * edgeDelta.y) /\n    (edgeDelta.x * edgeDelta.x + edgeDelta.y * edgeDelta.y);\n\n  result.u = u;\n\n  const proj = set(\n    result.projectedPoint,\n    endpoint1.x + u * edgeDelta.x,\n    endpoint1.y + u * edgeDelta.y\n  );\n\n  result.distance = distance(proj, point);\n\n  // given:\n  // E1----------------------E2        Proj\n  //           |                        |\n  //           | EdgeNorm               | perp\n  //           |                       Point\n  // \n  // What is the similarity (dot product) between EdgeNorm and Perp?\n  const edgeNorm = normal(result.edgeNormal, endpoint1, endpoint2);\n  sub(perp, point, proj);\n  result.similarity = dot(edgeNorm, perp);\n}\n","import { v2, Vector2, sub, normalize, scale, add } from \"./v2\";\nimport { Integratable } from \"./common-types\";\n\n// preallocations\nconst v = v2();\nconst direction = v2();\nconst radiusSegment = v2();\n\n/**\n * Compute the leading edge of a circular moving object given a radius: cpos + radius in the direction of velocity.\n */\nexport const projectCposWithRadius = (\n  out: Vector2,\n  p: Integratable,\n  radius: number\n) => {\n  sub(v, p.cpos, p.ppos);\n  normalize(direction, v);\n  scale(radiusSegment, direction, radius);\n  add(out, radiusSegment, p.cpos);\n  return out;\n}\n","import scihalt from \"science-halt\";\nimport {\n  add,\n  scale,\n  sub,\n  v2,\n  AABBOverlapResult,\n  accelerate,\n  inertia,\n  overlapAABBAABB,\n  collisionResponseAABB,\n  Vector2\n} from \"../src\";\n\ntype Box = {\n  cpos: Vector2;\n  ppos: Vector2;\n  acel: Vector2;\n  w: number;\n  h: number;\n  mass: number;\n}\n\nexport const start = () => {\n  const cvs = document.createElement(\"canvas\");\n  const ctx = cvs.getContext(\"2d\")!;\n  cvs.width = cvs.height = 800;\n  cvs.style.border = \"1px solid gray\";\n  document.body.appendChild(cvs);\n\n  const box1 = {\n    cpos: v2(350, 90),\n    ppos: v2(349, 80),\n    acel: v2(),\n    w: 100,\n    h: 150,\n    mass: 10\n  };\n\n  const box2 = {\n    cpos: v2(350, 600),\n    ppos: v2(350, 600),\n    acel: v2(),\n    w: 100,\n    h: 150,\n    mass: 10\n  };\n\n  const points: Box[] = [];\n  const collision: AABBOverlapResult = {\n    resolve: v2(),\n    hitPos: v2(),\n    normal: v2()\n  };\n\n  points.push(box1, box2);\n\n  let running = true;\n  scihalt(() => (running = false));\n\n  (function step() {\n    const dt = 1;\n    for (let i = 0; i < points.length; i++) {\n      const point = points[i];\n      accelerate(point, dt);\n    }\n\n    const isOverlapping = overlapAABBAABB(\n      box1.cpos.x,\n      box1.cpos.y,\n      box1.w,\n      box1.h,\n      box2.cpos.x,\n      box2.cpos.y,\n      box2.w,\n      box2.h,\n      collision\n    );\n\n    if (isOverlapping) {\n      // for debugging\n      render(points, ctx);\n\n      // move to non-overlapping position\n      const overlapHalf = scale(v2(), collision.resolve, 0.5);\n      add(box2.cpos, box2.cpos, overlapHalf);\n      add(box2.ppos, box2.ppos, overlapHalf);\n      sub(box1.cpos, box1.cpos, overlapHalf);\n      sub(box1.ppos, box1.ppos, overlapHalf);\n\n      // for debugging\n      render(points, ctx);\n\n      const box1v = v2();\n      const box2v = v2();\n\n      const restitution = 1;\n      const staticFriction = 0.9;\n      const dynamicFriction = 0.01;\n\n      collisionResponseAABB(\n        box1.cpos,\n        box1.ppos,\n        box1.mass,\n        restitution,\n        staticFriction,\n        dynamicFriction,\n        box2.cpos,\n        box2.ppos,\n        box2.mass,\n        restitution,\n        staticFriction,\n        dynamicFriction,\n        // Allow the response function to recompute a normal based on the\n        // axis between the centers of the boxes. this produces a more\n        // natural looking collision.\n        // collision.normal,\n        v2(),\n        box1v,\n        box2v\n      );\n\n      // Apply the new velocity\n      sub(box1.ppos, box1.cpos, box1v);\n      sub(box2.ppos, box2.cpos, box2v);\n\n      // for debugging\n      render(points, ctx);\n    }\n\n    for (let i = 0; i < points.length; i++) {\n      const point = points[i];\n      inertia(point);\n    }\n\n    render(points, ctx);\n    if (!running) return;\n    window.requestAnimationFrame(step);\n  })();\n\n  function render(points: Box[], ctx: CanvasRenderingContext2D) {\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n    for (let i = 0; i < points.length; i++) {\n      const point = points[i];\n\n      ctx.fillStyle = \"red\";\n      ctx.fillRect(\n        point.ppos.x - point.w / 2,\n        point.ppos.y - point.h / 2,\n        point.w,\n        point.h\n      );\n\n      ctx.fillStyle = \"black\";\n      ctx.fillRect(\n        point.cpos.x - point.w / 2,\n        point.cpos.y - point.h / 2,\n        point.w,\n        point.h\n      );\n    }\n  }\n};\n","import scihalt from \"science-halt\";\nimport {\n  add,\n  distance,\n  scale,\n  sub,\n  v2,\n  accelerate,\n  inertia,\n  solveGravitation,\n  overlapAABBAABB,\n  collisionResponseAABB,\n  AABBOverlapResult,\n  copy\n} from \"../src/index\";\n\nexport const start = () => {\n  const cvs = document.createElement(\"canvas\");\n  const ctx = cvs.getContext(\"2d\")!;\n  cvs.width = cvs.height = 800;\n  cvs.style.border = \"1px solid gray\";\n  document.body.appendChild(cvs);\n\n  type Box = ReturnType<typeof makeBox>;\n\n  const points: Box[] = [];\n\n  for (let count = 25, i = 0; i < count; i++) {\n    const centerX = cvs.width / 2;\n    const centerY = cvs.height / 2;\n    const distance = Math.min(centerX, centerY) * 0.5;\n    const cos = Math.cos(i);\n    const sin = Math.sin(i);\n    const x = centerX + cos * distance;\n    const y = centerY + sin * distance;\n    points.push(makeBox(x, y));\n  }\n\n  const GRAVITATIONAL_POINT = {\n    cpos: v2(cvs.width / 2, cvs.height / 2),\n    ppos: v2(cvs.width / 2, cvs.height / 2),\n    acel: v2(),\n    mass: 100000\n  };\n\n  let running = true;\n  scihalt(() => (running = false));\n\n  (function step() {\n    for (let i = 0; i < points.length; i++) {\n      const point = points[i];\n      const dist = distance(point.cpos, GRAVITATIONAL_POINT.cpos);\n      dist > 100 &&\n        solveGravitation(\n          point,\n          point.mass,\n          GRAVITATIONAL_POINT,\n          GRAVITATIONAL_POINT.mass\n        );\n    }\n\n    const dt = 1;\n    for (let i = 0; i < points.length; i++) {\n      const point = points[i];\n      accelerate(point, dt);\n    }\n\n    const collisions = [];\n    const handled = [];\n    const collision: AABBOverlapResult = {\n      resolve: v2(),\n      hitPos: v2(),\n      normal: v2()\n    };\n\n    for (let i = 0; i < points.length; i++) {\n      for (let j = i + 1; j < points.length; j++) {\n        const box1 = points[i];\n        const box2 = points[j];\n        const isOverlapping = overlapAABBAABB(\n          box1.cpos.x,\n          box1.cpos.y,\n          box1.w,\n          box1.h,\n          box2.cpos.x,\n          box2.cpos.y,\n          box2.w,\n          box2.h,\n          collision\n        );\n\n        if (\n          isOverlapping &&\n          handled.indexOf(box1.id + \",\" + box2.id) === -1 &&\n          handled.indexOf(box2.id + \",\" + box1.id) === -1\n        ) {\n          // move to non-overlapping position\n          const overlapHalf = scale(v2(), collision.resolve, 0.5);\n          add(box2.cpos, box2.cpos, overlapHalf);\n          add(box2.ppos, box2.ppos, overlapHalf);\n          sub(box1.cpos, box1.cpos, overlapHalf);\n          sub(box1.ppos, box1.ppos, overlapHalf);\n\n          // for debugging\n          render(points, ctx);\n\n          const box1v = v2();\n          const box2v = v2();\n\n          const restitution = 1;\n          const staticFriction = 0.9;\n          const dynamicFriction = 0.01;\n\n          collisionResponseAABB(\n            box1.cpos,\n            box1.ppos,\n            box1.mass,\n            restitution,\n            staticFriction,\n            dynamicFriction,\n            box2.cpos,\n            box2.ppos,\n            box2.mass,\n            restitution,\n            staticFriction,\n            dynamicFriction,\n            // Allow the response function to recompute a normal based on the\n            // axis between the centers of the boxes. this produces a more\n            // natural looking collision.\n            // collision.normal,\n            v2(),\n            box1v,\n            box2v\n          );\n\n          // Apply the new velocity\n          sub(box1.ppos, box1.cpos, box1v);\n          sub(box2.ppos, box2.cpos, box2v);\n\n          // for debugging\n          render(points, ctx);\n\n          handled.push(box1.id + \",\" + box2.id);\n          handled.push(box2.id + \",\" + box1.id);\n        }\n      }\n    }\n\n    for (let i = 0; i < points.length; i++) {\n      const point = points[i];\n      inertia(point);\n    }\n\n    render(points, ctx);\n    if (!running) return;\n    window.requestAnimationFrame(step);\n  })();\n\n  function makeBox(x: number, y: number) {\n    return {\n      id: \"id-\" + Math.floor(Math.random() * 10000000),\n      cpos: v2(x, y),\n      ppos: v2(x, y),\n      acel: v2(),\n      mass: 10,\n      w: 10,\n      h: 10\n    };\n  }\n\n  function render(points: Box[], ctx: CanvasRenderingContext2D) {\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n    for (let i = 0; i < points.length; i++) {\n      const point = points[i];\n\n      ctx.fillStyle = \"red\";\n      ctx.fillRect(\n        point.ppos.x - point.w / 2,\n        point.ppos.y - point.h / 2,\n        point.w,\n        point.h\n      );\n\n      ctx.fillStyle = \"black\";\n      ctx.fillRect(\n        point.cpos.x - point.w / 2,\n        point.cpos.y - point.h / 2,\n        point.w,\n        point.h\n      );\n    }\n  }\n};\n","import scihalt from \"science-halt\";\nimport {\n  add,\n  copy,\n  normalize,\n  scale,\n  sub,\n  v2,\n  accelerate,\n  inertia,\n  solveGravitation,\n  overlapCircleCircle,\n  collideCircleCircle,\n  Vector2\n} from \"../src/index\";\n\nexport const start = () => {\n  const cvs = document.createElement(\"canvas\");\n  const ctx = cvs.getContext(\"2d\")!;\n  cvs.width = cvs.height = 800;\n  cvs.style.border = \"1px solid gray\";\n  document.body.appendChild(cvs);\n\n  type Point = (ReturnType<typeof generatePoints>)[0];\n\n  // generate a circle of circles\n  const CENTER = { x: 400, y: 400 };\n  const GRAVITATIONAL_POINT = {\n    cpos: copy(v2(), CENTER),\n    ppos: copy(v2(), CENTER),\n    acel: v2(),\n    radius: 20,\n    mass: 10000\n  };\n  const RADIUS = 15;\n  const DAMPING = 0.1;\n  const points = generatePoints(CENTER, RADIUS, 40);\n  const colliding: Point[] = [];\n\n  points.unshift(GRAVITATIONAL_POINT);\n\n  let running = true;\n  scihalt(() => (running = false));\n\n  let ticks = 0;\n\n  (function step() {\n    const force = v2();\n    const dt = 16;\n    for (let i = 0; i < points.length; i++) {\n      const point = points[i];\n      if (point !== GRAVITATIONAL_POINT && ticks < 100) {\n        solveGravitation(\n          point,\n          point.mass,\n          GRAVITATIONAL_POINT,\n          GRAVITATIONAL_POINT.mass\n        );\n        //sub(force, GRAVITATIONAL_POINT.cpos, point.cpos);\n        //normalize(force, force);\n        //scale(force, force, 50);\n        //add(point.acel, point.acel, force);\n      }\n      accelerate(point, dt);\n    }\n\n    collisionPairs(colliding, points);\n\n    for (let i = 0; i < colliding.length; i += 2) {\n      const pointA = colliding[i];\n      const pointB = colliding[i + 1];\n      collideCircleCircle(\n        pointA,\n        pointA.radius,\n        pointA.mass,\n        pointB,\n        pointB.radius,\n        pointB.mass,\n        false,\n        DAMPING\n      );\n    }\n\n    for (let i = 0; i < points.length; i++) {\n      const point = points[i];\n      inertia(point);\n    }\n\n    // TODO: the original demo code technically \"detects\" collisions with each\n    // iteration, but when we do this, it actually becomes more unstable. \n    // collisionPairs(colliding, points);\n\n    for (let i = 0; i < colliding.length; i += 2) {\n      const pointA = colliding[i];\n      const pointB = colliding[i + 1];\n      collideCircleCircle(\n        pointA,\n        pointA.radius,\n        pointA.mass,\n        pointB,\n        pointB.radius,\n        pointB.mass,\n        true,\n        DAMPING\n      );\n    }\n\n    render(points, ctx);\n    ticks++;\n    if (!running) return;\n    window.requestAnimationFrame(step);\n  })();\n\n  function collisionPairs(pairs: Point[], points: Point[]) {\n    pairs.length = 0;\n\n    for (let i = 0; i < points.length; i++) {\n      const pointA = points[i];\n      for (let j = i + 1; j < points.length; j++) {\n        const pointB = points[j];\n        if (\n          overlapCircleCircle(\n            pointA.cpos.x,\n            pointA.cpos.y,\n            pointA.radius,\n            pointB.cpos.x,\n            pointB.cpos.y,\n            pointB.radius\n          )\n        ) {\n          pairs.push(pointA, pointB);\n        }\n      }\n    }\n\n    return pairs;\n  }\n\n  function generatePoints(center: Vector2, baseRadius: number, num: number) {\n    const all = [];\n    const minRadius = 10;\n    for (let i = 0; i < num; i++) {\n      const x = Math.cos(i) * center.x + center.x;\n      const y = Math.sin(i) * center.y + center.y;\n      all.push({\n        cpos: { x, y },\n        ppos: { x, y },\n        acel: { x: 0, y: 0 },\n        radius: Math.max(\n          Math.abs(Math.cos(i) + Math.sin(i)) * baseRadius,\n          minRadius\n        ),\n        mass: Math.max(Math.abs(Math.cos(i) + Math.sin(i)) * 1, 1)\n      });\n    }\n    return all;\n  }\n\n  function render(points: Point[], ctx: CanvasRenderingContext2D) {\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n    for (let i = 0; i < points.length; i++) {\n      const point = points[i];\n\n      ctx.fillStyle = \"red\";\n      ctx.beginPath();\n      ctx.arc(point.ppos.x, point.ppos.y, point.radius, 0, Math.PI * 2, false);\n      ctx.fill();\n\n      ctx.fillStyle = \"black\";\n      ctx.beginPath();\n      ctx.arc(point.cpos.x, point.cpos.y, point.radius, 0, Math.PI * 2, false);\n      ctx.fill();\n    }\n  }\n};\n","import scihalt from \"science-halt\";\nimport {\n  add,\n  copy,\n  normalize,\n  scale,\n  sub,\n  v2,\n  accelerate,\n  inertia,\n  solveGravitation,\n  overlapCircleCircle,\n  collideCircleCircle,\n  collideCircleEdge,\n  solveDistanceConstraint,\n  rewindToCollisionPoint,\n  Vector2,\n  VelocityDerivable,\n  distance,\n  Integratable\n} from \"../src/index\";\n\nexport const start = () => {\n  const cvs = document.createElement(\"canvas\");\n  const ctx = cvs.getContext(\"2d\")!;\n  cvs.width = cvs.height = 800;\n  cvs.style.border = \"1px solid gray\";\n  document.body.appendChild(cvs);\n\n  type CollidableLine = {\n    point1: CollidableCircle;\n    point2: CollidableCircle;\n  };\n\n  type CollidableCircle = {\n    mass: number;\n    radius: number;\n  } & Integratable;\n\n  type DistanceConstraint = {\n    point1: Exclude<CollidableCircle, \"radius\">;\n    point2: Exclude<CollidableCircle, \"radius\">;\n    goal: number;\n  };\n\n  const CONSTRAINT_ITERATIONS = 2;\n\n  const circles: CollidableCircle[] = [];\n  const lines: CollidableLine[] = [];\n  const constraints: DistanceConstraint[] = [];\n\n  const box = makeBox(300, 200, 100, 200);\n  circles.push(...box.circles);\n  lines.push(...box.lines);\n  constraints.push(...box.constraints);\n\n  circles.push({\n    cpos: v2(500, 390),\n    ppos: v2(510, 390),\n    acel: v2(0, 0),\n    mass: 100,\n    radius: 10\n  });\n\n  let running = true;\n  scihalt(() => (running = false));\n\n  (function step() {\n    const dt = 16;\n\n    for (let i = 0; i < circles.length; i++) {\n      const circle = circles[i];\n      accelerate(circle, dt);\n    }\n\n    for (let i = 0; i < CONSTRAINT_ITERATIONS; i++) {\n      for (let j = 0; j < constraints.length; j++) {\n        const constraint = constraints[j];\n        solveDistanceConstraint(\n          constraint.point1,\n          constraint.point1.mass,\n          constraint.point2,\n          constraint.point2.mass,\n          constraint.goal\n        );\n      }\n    }\n\n    collideCircles(circles, false);\n    collideEdges(lines, circles, false);\n\n    for (let i = 0; i < circles.length; i++) {\n      const circle = circles[i];\n      inertia(circle);\n    }\n\n    collideCircles(circles, true);\n    collideEdges(lines, circles, true);\n\n    render(circles, lines, ctx);\n    if (!running) return;\n    window.requestAnimationFrame(step);\n  })();\n\n  function makeBox(x: number, y: number, width: number, height: number) {\n    const lines: CollidableLine[] = [];\n    const circles: CollidableCircle[] = [];\n    const constraints: DistanceConstraint[] = [];\n    const points = [\n      v2(x, y),\n      v2(x + width, y),\n      v2(x + width, y + height),\n      v2(x, y + height)\n    ];\n    for (let i = 0; i < points.length; i++) {\n      const point = points[i];\n      const prev = circles.length === 0 ? null : circles[i - 1];\n      const circle = {\n        cpos: copy(v2(), point),\n        ppos: copy(v2(), point),\n        acel: v2(0, 0),\n        mass: i === 0 ? -1 : 1,\n        radius: 1\n      };\n      if (prev) {\n        lines.push({\n          point1: prev,\n          point2: circle\n        });\n\n        constraints.push({\n          point1: prev,\n          point2: circle,\n          goal: distance(point, prev.cpos)\n        });\n      }\n      circles.push(circle);\n    }\n\n    lines.push({\n      point1: circles[circles.length - 1],\n      point2: circles[0]\n    });\n\n    constraints.push({\n      point1: circles[circles.length - 1],\n      point2: circles[0],\n      goal: distance(circles[circles.length - 1].cpos, circles[0].cpos)\n    });\n\n    constraints.push({\n      point1: circles[0],\n      point2: circles[2],\n      goal: distance(circles[0].cpos, circles[2].cpos)\n    });\n\n    return {\n      lines,\n      circles,\n      constraints\n    };\n  }\n\n  function collideCircles(\n    circles: CollidableCircle[],\n    preserveInertia: boolean,\n    damping = 0.9\n  ) {\n    for (let i = 0; i < circles.length; i++) {\n      const a = circles[i];\n      for (let j = i + 1; j < circles.length; j++) {\n        const b = circles[j];\n        if (\n          !overlapCircleCircle(\n            a.cpos.x,\n            a.cpos.y,\n            a.radius,\n            b.cpos.x,\n            b.cpos.y,\n            b.radius\n          )\n        )\n          continue;\n        collideCircleCircle(\n          a,\n          a.radius,\n          a.mass,\n          b,\n          b.radius,\n          b.mass,\n          preserveInertia,\n          damping\n        );\n      }\n    }\n  }\n\n  function collideEdges(\n    lines: CollidableLine[],\n    circles: CollidableCircle[],\n    preserveInertia: boolean,\n    damping = 0.9\n  ) {\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i];\n      for (let j = 0; j < circles.length; j++) {\n        const circle = circles[j];\n        // Don't collide with yourself! This would be very very bad.\n        if (line.point1 == circle || line.point2 === circle) continue;\n        if (!preserveInertia)\n          rewindToCollisionPoint(\n            circle,\n            circle.radius,\n            line.point1.cpos,\n            line.point2.cpos\n          );\n        collideCircleEdge(\n          circle,\n          circle.radius,\n          circle.mass,\n          line.point1,\n          line.point1.mass,\n          line.point2,\n          line.point2.mass,\n          preserveInertia,\n          damping\n        );\n      }\n    }\n  }\n\n  function render(\n    circles: CollidableCircle[],\n    segments: CollidableLine[],\n    ctx: CanvasRenderingContext2D\n  ) {\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n    for (let i = 0; i < circles.length; i++) {\n      const point = circles[i];\n\n      ctx.fillStyle = \"red\";\n      ctx.beginPath();\n      ctx.arc(point.ppos.x, point.ppos.y, point.radius, 0, Math.PI * 2, false);\n      ctx.fill();\n\n      ctx.fillStyle = \"black\";\n      ctx.beginPath();\n      ctx.arc(point.cpos.x, point.cpos.y, point.radius, 0, Math.PI * 2, false);\n      ctx.fill();\n    }\n\n    for (let i = 0; i < segments.length; i++) {\n      const segment = segments[i];\n      ctx.strokeStyle = \"red\";\n      ctx.beginPath();\n      ctx.moveTo(segment.point1.ppos.x, segment.point1.ppos.y);\n      ctx.lineTo(segment.point2.ppos.x, segment.point2.ppos.y);\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.strokeStyle = \"black\";\n      ctx.moveTo(segment.point1.cpos.x, segment.point1.cpos.y);\n      ctx.lineTo(segment.point2.cpos.x, segment.point2.cpos.y);\n      ctx.stroke();\n    }\n  }\n};\n","import scihalt from \"science-halt\";\nimport {\n  Vector2,\n  v2,\n  accelerate,\n  inertia,\n  add,\n  collideCircleEdge,\n  rewindToCollisionPoint,\n  solveDistanceConstraint\n} from \"../src\";\n\nexport const start = () => {\n  const cvs = document.createElement(\"canvas\");\n  const ctx = cvs.getContext(\"2d\")!;\n  cvs.tabIndex = 1; // for keyboard events\n  cvs.width = cvs.height = 800;\n  cvs.style.border = \"1px solid gray\";\n  document.body.appendChild(cvs);\n\n  type CollidableLine = {\n    point1: CollidableCircle;\n    point2: CollidableCircle;\n    goal: number;\n  };\n\n  type CollidableCircle = {\n    cpos: Vector2;\n    ppos: Vector2;\n    acel: Vector2;\n    mass: number;\n    radius: number;\n  };\n\n  const player: CollidableCircle = {\n    cpos: v2(600, 0),\n    ppos: v2(600, 0),\n    acel: v2(0, 0),\n    mass: 1,\n    radius: 20\n  };\n\n  const GRAVITY = 0.8;\n\n  const platform: CollidableLine = {\n    point1: {\n      cpos: v2(100, 300),\n      ppos: v2(100, 300),\n      acel: v2(0, 0),\n      // mass: 100000000,\n      mass: -1,\n      radius: 0\n    },\n    point2: {\n      cpos: v2(700, 300),\n      ppos: v2(700, 300),\n      acel: v2(0, 0),\n      // mass: 100000000,\n      // mass: -1,\n      mass: -1,\n      radius: 0\n    },\n    goal: 500\n  };\n\n  const circles: CollidableCircle[] = [\n    player,\n    platform.point1,\n    platform.point2\n  ];\n\n  const tunnelPoint = v2();\n\n  let running = true;\n  scihalt(() => (running = false));\n\n  // const keys: { [key: string]: boolean } = {};\n  // cvs.addEventListener(\"keydown\", e => {\n  //   keys[e.key] = true;\n  //   e.preventDefault();\n  // });\n  // document.body.addEventListener(\"keyup\", e => {\n  //   keys[e.key] = false;\n  //   e.preventDefault();\n  // });\n\n  (function step() {\n    const dt = 16;\n\n    // gravity!\n    add(player.acel, player.acel, v2(0, GRAVITY));\n\n    for (let i = 0; i < circles.length; i++) {\n      const box = circles[i];\n      accelerate(box, dt);\n    }\n\n    rewindToCollisionPoint(player, player.radius, platform.point1.cpos, platform.point2.cpos);\n\n    collideCircleEdge(\n      player,\n      player.radius,\n      player.mass,\n      platform.point1,\n      platform.point1.mass,\n      platform.point2,\n      platform.point2.mass,\n      false,\n      0.9\n    );\n\n    for (let i = 0; i < circles.length; i++) {\n      const box = circles[i];\n      inertia(box);\n    }\n\n    collideCircleEdge(\n      player,\n      player.radius,\n      player.mass,\n      platform.point1,\n      platform.point1.mass,\n      platform.point2,\n      platform.point2.mass,\n      true,\n      0.9\n    );\n\n    for (let i = 0; i < 5; i++) {\n      solveDistanceConstraint(\n        platform.point1,\n        platform.point1.mass,\n        platform.point2,\n        platform.point2.mass,\n        platform.goal\n      );\n    }\n\n    render(circles, [platform], ctx);\n    if (!running) return;\n    window.requestAnimationFrame(step);\n  })();\n\n  function render(\n    circles: CollidableCircle[],\n    segments: CollidableLine[],\n    ctx: CanvasRenderingContext2D\n  ) {\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n    for (let i = 0; i < circles.length; i++) {\n      const point = circles[i];\n\n      ctx.fillStyle = \"red\";\n      ctx.beginPath();\n      ctx.arc(point.ppos.x, point.ppos.y, point.radius, 0, Math.PI * 2, false);\n      ctx.fill();\n\n      ctx.fillStyle = \"black\";\n      ctx.beginPath();\n      ctx.arc(point.cpos.x, point.cpos.y, point.radius, 0, Math.PI * 2, false);\n      ctx.fill();\n    }\n\n    for (let i = 0; i < segments.length; i++) {\n      const segment = segments[i];\n      ctx.strokeStyle = \"red\";\n      ctx.beginPath();\n      ctx.moveTo(segment.point1.ppos.x, segment.point1.ppos.y);\n      ctx.lineTo(segment.point2.ppos.x, segment.point2.ppos.y);\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.strokeStyle = \"black\";\n      ctx.moveTo(segment.point1.cpos.x, segment.point1.cpos.y);\n      ctx.lineTo(segment.point2.cpos.x, segment.point2.cpos.y);\n      ctx.stroke();\n    }\n  }\n};\n","import scihalt from \"science-halt\";\nimport {\n  Vector2,\n  v2,\n  accelerate,\n  overlapAABBAABB,\n  AABBOverlapResult,\n  inertia,\n  add,\n  scale,\n  collisionResponseAABB,\n  sub,\n  translate\n} from \"../src\";\n\nexport const start = () => {\n  const cvs = document.createElement(\"canvas\");\n  const ctx = cvs.getContext(\"2d\")!;\n  cvs.tabIndex = 1; // for keyboard events\n  cvs.width = cvs.height = 800;\n  cvs.style.border = \"1px solid gray\";\n  document.body.appendChild(cvs);\n\n  type CollidableBox = {\n    cpos: Vector2;\n    ppos: Vector2;\n    acel: Vector2;\n    width: number;\n    height: number;\n    mass: number;\n  };\n\n  const player: CollidableBox = {\n    cpos: v2(400, 0),\n    ppos: v2(400, 0),\n    acel: v2(0, 0),\n    width: 50,\n    height: 75,\n    mass: 1\n  };\n\n  const PLAYER_HOR_ACEL = 5;\n  const GRAVITY = 9.8;\n\n  const platform: CollidableBox = {\n    cpos: v2(400, 700),\n    ppos: v2(400, 700),\n    acel: v2(0, 0),\n    width: 800,\n    height: 100,\n    mass: Number.MAX_SAFE_INTEGER - 100000\n  };\n\n  const boxes: CollidableBox[] = [player, platform];\n\n  const collision: AABBOverlapResult = {\n    resolve: v2(),\n    hitPos: v2(),\n    normal: v2()\n  };\n\n  let running = true;\n  scihalt(() => (running = false));\n\n  const keys: { [key: string]: boolean } = {};\n  cvs.addEventListener(\"keydown\", e => {\n    keys[e.key] = true;\n    e.preventDefault();\n  });\n  document.body.addEventListener(\"keyup\", e => {\n    keys[e.key] = false;\n    e.preventDefault();\n  });\n\n  (function step() {\n    const dt = 16;\n\n    // gravity!\n    add(player.acel, player.acel, v2(0, GRAVITY));\n\n    for (let i = 0; i < boxes.length; i++) {\n      const box = boxes[i];\n      accelerate(box, dt);\n    }\n\n    const isOverlapping = overlapAABBAABB(\n      player.cpos.x,\n      player.cpos.y,\n      player.width,\n      player.height,\n      platform.cpos.x,\n      platform.cpos.y,\n      platform.width,\n      platform.height,\n      collision\n    );\n\n    if (isOverlapping) {\n      // Move to non-overlapping positions\n      const negativeResolve = scale(v2(), collision.resolve, -1);\n      // translate(overlapHalf, platform.cpos, platform.ppos);\n      translate(negativeResolve, player.cpos, player.ppos);\n\n      // for debugging\n      render(boxes, ctx);\n\n      // We will put the new relative velocity vectors here.\n      const box1v = v2();\n      const box2v = v2();\n\n      const restitution = 1;\n      const staticFriction = 0.9;\n      const dynamicFriction = 0.1;\n\n      collisionResponseAABB(\n        player.cpos,\n        player.ppos,\n        player.mass,\n        restitution,\n        staticFriction,\n        dynamicFriction,\n        platform.cpos,\n        platform.ppos,\n        platform.mass,\n        restitution,\n        staticFriction,\n        dynamicFriction,\n        collision.normal,\n        box1v,\n        box2v\n      );\n\n      // Apply the new velocity\n      sub(player.ppos, player.cpos, box1v);\n      // Kill vertical velocity\n      player.ppos.y = player.cpos.y;\n\n      // for debugging\n      render(boxes, ctx);\n    }\n\n    // Movement in the air is less powerful than on the ground!\n\n    if (keys.ArrowLeft) {\n      add(\n        player.acel,\n        player.acel,\n        v2(isOverlapping ? -PLAYER_HOR_ACEL : -PLAYER_HOR_ACEL / 10, 0)\n      );\n    }\n\n    if (keys.ArrowRight) {\n      add(\n        player.acel,\n        player.acel,\n        v2(isOverlapping ? PLAYER_HOR_ACEL : PLAYER_HOR_ACEL / 10, 0)\n      );\n    }\n\n    // we were overlapping, so probably ok to jump!\n    if (isOverlapping && keys.ArrowUp && player.cpos.y - player.ppos.y === 0) {\n      add(player.acel, player.acel, v2(0, -GRAVITY * 10));\n    }\n\n    for (let i = 0; i < boxes.length; i++) {\n      const box = boxes[i];\n      inertia(box);\n    }\n\n    render(boxes, ctx);\n    if (!running) return;\n    window.requestAnimationFrame(step);\n  })();\n\n  function render(boxes: CollidableBox[], ctx: CanvasRenderingContext2D) {\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n    for (let i = 0; i < boxes.length; i++) {\n      const box = boxes[i];\n\n      ctx.fillStyle = \"red\";\n      ctx.fillRect(\n        box.ppos.x - box.width / 2,\n        box.ppos.y - box.height / 2,\n        box.width,\n        box.height\n      );\n\n      ctx.fillStyle = \"black\";\n      ctx.fillRect(\n        box.cpos.x - box.width / 2,\n        box.cpos.y - box.height / 2,\n        box.width,\n        box.height\n      );\n    }\n  }\n};\n","import scihalt from \"science-halt\";\nimport {\n  Vector2,\n  v2,\n  copy,\n  accelerate,\n  inertia,\n  add,\n  distance,\n  collideCircleEdge,\n  rewindToCollisionPoint,\n  collideCircleCircle,\n  overlapCircleCircle,\n  segmentIntersection,\n  sub,\n  normalize,\n  scale,\n  normal,\n  dot,\n  solveDistanceConstraint,\n  projectPointEdge,\n  PointEdgeProjection,\n  createPointEdgeProjectionResult\n} from \"../src\";\n\nexport const start = () => {\n  const width = 800;\n  const cvs = document.createElement(\"canvas\");\n  const ctx = cvs.getContext(\"2d\")!;\n  cvs.tabIndex = 1; // for keyboard events\n  cvs.width = cvs.height = width;\n  cvs.style.border = \"1px solid gray\";\n  document.body.appendChild(cvs);\n\n  type CollidableLine = {\n    point1: CollidableCircle;\n    point2: CollidableCircle;\n  };\n\n  type CollidableCircle = {\n    cpos: Vector2;\n    ppos: Vector2;\n    acel: Vector2;\n    mass: number;\n    radius: number;\n  };\n\n  type DistanceConstraint = {\n    point1: Exclude<CollidableCircle, \"radius\">;\n    point2: Exclude<CollidableCircle, \"radius\">;\n    goal: number;\n  };\n\n  const GRAVITY = 0.8;\n  const CONSTRAINT_ITERS = 5;\n\n  const lines: CollidableLine[] = [];\n  const constraints: DistanceConstraint[] = [];\n  const circles: CollidableCircle[] = [];\n\n  const bucket = makeStaticMesh([\n    v2(50, 50),\n    v2(width - 50, 50),\n    v2(width - 50, width - 50),\n    v2(50, width - 50)\n  ]);\n\n  const midLine = makeStaticMesh([\n    v2(500, width / 2),\n    v2(width - 500, width / 2 + 200)\n  ]);\n  midLine.pop(); // remove the double link back to beginning\n  lines.push(...bucket, ...midLine);\n\n  circles.push(...makeCircles(v2(width / 2, width / 2), width / 4, 10, 400));\n\n  const polys = [\n    makePolygon(6, v2(300, 100), 15),\n    makePolygon(3, v2(400, 100), 15),\n    makePolygon(4, v2(600, 100), 15),\n  ];\n\n  polys.forEach(poly => {\n    circles.push(...poly.circles);\n    constraints.push(...poly.constraints);\n    lines.push(...poly.lines);\n  });\n\n  let running = true;\n  scihalt(() => (running = false));\n\n  (function step() {\n    const dt = 16;\n\n    for (let i = 0; i < circles.length; i++) {\n      const circle = circles[i];\n\n      if (circle.mass > 0) {\n        add(circle.acel, circle.acel, v2(0, GRAVITY));\n      }\n\n      accelerate(circle, dt);\n    }\n\n    for (let i = 0; i < CONSTRAINT_ITERS; i++) {\n      for (let j = 0; j < constraints.length; j++) {\n        const constraint = constraints[j];\n        solveDistanceConstraint(\n          constraint.point1,\n          constraint.point1.mass,\n          constraint.point2,\n          constraint.point2.mass,\n          constraint.goal,\n          1\n        );\n      }\n    }\n\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i];\n      const lineIsBounds = bucket.indexOf(line) > -1;\n      for (let j = 0; j < circles.length; j++) {\n        const circle = circles[j];\n        if (circle === line.point1 || circle === line.point2) continue;\n        // TODO: this needs to be smarter. Without this rewind, simple circles\n        // will tunnel through the line. But if done indiscriminately, the rewind\n        // will cause an infinite build up of velocity, and eventually explode. OR\n        // it will cause a circle to \"stick\" to an edge until their velocity\n        // dissipates.\n        if (!lineIsBounds) {\n          rewindToCollisionPoint(circle, circle.radius, line.point1.cpos, line.point2.cpos);\n        }\n        \n        collideCircleEdge(\n          circle,\n          circle.radius,\n          circle.mass,\n          line.point1,\n          line.point1.mass,\n          line.point2,\n          line.point2.mass,\n          false,\n          0.9\n        );\n      }\n    }\n\n    for (let i = 0; i < circles.length; i++) {\n      const a = circles[i];\n      for (let j = i + 1; j < circles.length; j++) {\n        const b = circles[j];\n        if (\n          !overlapCircleCircle(\n            a.cpos.x,\n            a.cpos.y,\n            a.radius,\n            b.cpos.x,\n            b.cpos.y,\n            b.radius\n          )\n        )\n          continue;\n        collideCircleCircle(\n          a,\n          a.radius,\n          a.mass,\n          b,\n          b.radius,\n          b.mass,\n          false,\n          0.9\n        );\n      }\n    }\n\n    for (let i = 0; i < circles.length; i++) {\n      const circle = circles[i];\n      inertia(circle);\n    }\n\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i];\n      for (let j = 0; j < circles.length; j++) {\n        const circle = circles[j];\n        if (circle === line.point1 || circle === line.point2) continue;\n        collideCircleEdge(\n          circle,\n          circle.radius,\n          circle.mass,\n          line.point1,\n          line.point1.mass,\n          line.point2,\n          line.point2.mass,\n          true,\n          0.9\n        );\n      }\n    }\n\n    for (let i = 0; i < circles.length; i++) {\n      const a = circles[i];\n      for (let j = i + 1; j < circles.length; j++) {\n        const b = circles[j];\n        if (\n          !overlapCircleCircle(\n            a.cpos.x,\n            a.cpos.y,\n            a.radius,\n            b.cpos.x,\n            b.cpos.y,\n            b.radius\n          )\n        )\n          continue;\n        collideCircleCircle(\n          a,\n          a.radius,\n          a.mass,\n          b,\n          b.radius,\n          b.mass,\n          true,\n          0.9\n        );\n      }\n    }\n\n    // Ensure nothing actually gets out of the bucket.\n    // It's impossible to keep everything in the bucket without a strict\n    // normal for each edge, because you need to know which \"side\" of the edge\n    // the particle is on. Additionally, the solver steps above can easily move\n    // a circle to a non-intersecting position that is beyond the \"knowledge\" of\n    // anything checking for collisions with edges. This is especially common\n    // when lots of collisions are being resolved.\n    for (let i = 0; i < bucket.length; i++) {\n      const line = bucket[i];\n      // HACK: Don't use the midline collection for bounds checking.\n      // The right way to do this is to create systems.\n      if (line === midLine[0]) continue;\n\n      for (let j = 0; j < circles.length; j++) {\n        const circle = circles[j];\n\n        const projection = createPointEdgeProjectionResult();\n\n        // We know which way the edges were wound, so we implicitly know which order\n        // these points should be used in to compute the normal.\n        projectPointEdge(circle.cpos, line.point1.cpos, line.point2.cpos, projection);\n\n        // both the edge normal and the segment from edge to circle are\n        // facing a similar direction\n        // We only know it is > 0 because of the order line.point,point2 were inputted\n        // into the projection.\n        if (projection.similarity > 0) continue;\n\n        // If we get here, the directions so dissimilar that the circle must\n        // be on the other side of the edge! Move it back!\n        const offset = v2();\n        sub(offset, projection.projectedPoint, circle.cpos);\n        add(circle.cpos, circle.cpos, offset);\n        // Don't correct ppos, otherwise velocity will continue to increase\n        // forever.\n        // add(circle.ppos, circle.ppos, offset);\n      }\n    }\n\n    render(circles, lines, constraints, ctx);\n    if (!running) return;\n    window.requestAnimationFrame(step);\n  })();\n\n  function makeStaticMesh(points: Vector2[]) {\n    const clines: CollidableLine[] = [];\n    const circles: CollidableCircle[] = [];\n    for (let i = 0; i < points.length; i++) {\n      const point = points[i];\n      const prev = circles.length === 0 ? null : circles[i - 1];\n      const circle = {\n        cpos: copy(v2(), point),\n        ppos: copy(v2(), point),\n        acel: v2(0, 0),\n        mass: -1,\n        radius: 1\n      };\n      if (prev) {\n        const line = {\n          point1: prev,\n          point2: circle\n        };\n        clines.push(line);\n      }\n      circles.push(circle);\n    }\n\n    clines.push({\n      point1: circles[circles.length - 1],\n      point2: circles[0]\n    });\n\n    return clines;\n  }\n\n  function makeCircles(\n    center: Vector2,\n    spawnRadius: number,\n    baseRadius: number,\n    num: number\n  ): CollidableCircle[] {\n    const all = [];\n    const minRadius = 10;\n    for (let i = 0; i < num; i++) {\n      const x = center.x + Math.cos(i) * spawnRadius;\n      const y = center.y + Math.sin(i) * spawnRadius;\n      all.push({\n        cpos: { x, y },\n        ppos: { x, y },\n        acel: { x: 0, y: 0 },\n        radius: Math.max(\n          Math.abs(Math.cos(i) + Math.sin(i)) * baseRadius,\n          minRadius\n        ),\n        mass: Math.max(Math.abs(Math.cos(i) + Math.sin(i)) * 1, 1)\n      });\n    }\n    return all;\n  }\n\n  function makePolygon(gon: number, center: Vector2, radius: number) {\n    const clines: CollidableLine[] = [];\n    const circles: CollidableCircle[] = [];\n    const constraints: DistanceConstraint[] = [];\n    for (let i = 0; i < gon; i++) {\n      const x = center.x + Math.cos((i / gon) * Math.PI * 2) * radius;\n      const y = center.y + Math.sin((i / gon) * Math.PI * 2) * radius;\n      circles.push({\n        cpos: { x, y },\n        ppos: { x, y },\n        acel: { x: 0, y: 0 },\n        radius: 5,\n        mass: 5\n      });\n    }\n\n    for (let i = 0; i < circles.length; i++) {\n      const point1 = circles[i];\n      const point2 = i === circles.length - 1 ? circles[0] : circles[i + 1];\n      clines.push({\n        point1,\n        point2\n      });\n    }\n\n    for (let i = 0; i < circles.length; i++) {\n      const point1 = circles[i];\n      let j = i;\n      while (true) {\n        j++;\n        const point2 = circles[j % circles.length];\n        if (point2 === point1) break;\n        if (\n          constraints.find(\n            c =>\n              (c.point1 === point1 && c.point2 === point2) ||\n              (c.point2 === point1 && c.point1 === point2)\n          ) !== undefined\n        )\n          break;\n        constraints.push({\n          point1,\n          point2,\n          goal: distance(point1.cpos, point2.cpos)\n        });\n      }\n    }\n\n    return {\n      circles,\n      lines: clines,\n      constraints\n    };\n  }\n\n  function render(\n    circles: CollidableCircle[],\n    segments: CollidableLine[],\n    constraints: DistanceConstraint[],\n    ctx: CanvasRenderingContext2D\n  ) {\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n    for (let i = 0; i < circles.length; i++) {\n      const point = circles[i];\n\n      ctx.fillStyle = \"red\";\n      ctx.beginPath();\n      ctx.arc(point.ppos.x, point.ppos.y, point.radius, 0, Math.PI * 2, false);\n      ctx.fill();\n\n      ctx.fillStyle = \"black\";\n      ctx.beginPath();\n      ctx.arc(point.cpos.x, point.cpos.y, point.radius, 0, Math.PI * 2, false);\n      ctx.fill();\n    }\n\n    for (let i = 0; i < segments.length; i++) {\n      const segment = segments[i];\n      ctx.strokeStyle = \"red\";\n      ctx.beginPath();\n      ctx.moveTo(segment.point1.ppos.x, segment.point1.ppos.y);\n      ctx.lineTo(segment.point2.ppos.x, segment.point2.ppos.y);\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.strokeStyle = \"black\";\n      ctx.moveTo(segment.point1.cpos.x, segment.point1.cpos.y);\n      ctx.lineTo(segment.point2.cpos.x, segment.point2.cpos.y);\n      ctx.stroke();\n    }\n\n    for (let i = 0; i < constraints.length; i++) {\n      const c = constraints[i];\n      ctx.strokeStyle = \"magenta\";\n      ctx.beginPath();\n      ctx.moveTo(c.point1.ppos.x, c.point1.ppos.y);\n      ctx.lineTo(c.point2.ppos.x, c.point2.ppos.y);\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.strokeStyle = \"purple\";\n      ctx.moveTo(c.point1.cpos.x, c.point1.cpos.y);\n      ctx.lineTo(c.point2.cpos.x, c.point2.cpos.y);\n      ctx.stroke();\n    }\n  }\n};\n","import scihalt from \"science-halt\";\nimport {\n  Vector2,\n  v2,\n  accelerate,\n  inertia,\n  add,\n  solveDistanceConstraint,\n  collisionResponseAABB,\n  createPointEdgeProjectionResult,\n  projectPointEdge,\n  sub,\n  segmentIntersection,\n  projectCposWithRadius,\n  translate,\n} from \"../src\";\n\nexport const start = () => {\n  const cvs = document.createElement(\"canvas\");\n  const ctx = cvs.getContext(\"2d\")!;\n  cvs.tabIndex = 1; // for keyboard events\n  cvs.width = cvs.height = 800;\n  cvs.style.border = \"1px solid gray\";\n  document.body.appendChild(cvs);\n\n  type CollidableLine = {\n    point1: CollidableCircle;\n    point2: CollidableCircle;\n    goal: number;\n  };\n\n  type CollidableCircle = {\n    cpos: Vector2;\n    ppos: Vector2;\n    acel: Vector2;\n    mass: number;\n    radius: number;\n  };\n\n  const player: CollidableCircle = {\n    cpos: v2(600, 100),\n    ppos: v2(600, 100),\n    acel: v2(0, 0),\n    mass: 1,\n    radius: 20,\n  };\n\n  const GRAVITY = 0.98;\n\n  // Use similar masses because even if the platform is immobile, a huge mass\n  // will impart nearly all velocity into the ball, and make restitution and\n  // friction nearly meaningless.\n  const platform: CollidableLine = {\n    point1: {\n      cpos: v2(100, 300),\n      ppos: v2(100, 300),\n      acel: v2(0, 0),\n      mass: 1,\n      radius: 0,\n    },\n    point2: {\n      cpos: v2(700, 300),\n      ppos: v2(700, 300),\n      acel: v2(0, 0),\n      mass: 1,\n      radius: 0,\n    },\n    goal: 500,\n  };\n\n  const circles: CollidableCircle[] = [\n    player,\n    platform.point1,\n    platform.point2,\n  ];\n\n  let running = true;\n  scihalt(() => (running = false));\n\n  (function step() {\n    const dt = 16;\n\n    // gravity!\n    add(player.acel, player.acel, v2(0, GRAVITY));\n\n    for (let i = 0; i < circles.length; i++) {\n      const box = circles[i];\n      accelerate(box, dt);\n    }\n\n    // Use the ppos to account for tunneling: if the ppos->cpos vector is\n    // intersecting with the edge, and ppos is still <0, that means the circle\n    // has collided or even tunneled. But if the similarity is in the opposite\n    // direction, that could mean this circle has already collided this frame.\n    const projectedResult = createPointEdgeProjectionResult();\n    projectPointEdge(\n      player.ppos,\n      platform.point1.cpos,\n      platform.point2.cpos,\n      projectedResult\n    );\n\n    // Project the cpos using the radius just for the sake of doing a\n    // line-intersection. This can be a problem in environments with more than\n    // one collision happening per frame.\n    const intersectionPoint = v2();\n    const cposCapsule = projectCposWithRadius(v2(), player, player.radius);\n    const intersected = segmentIntersection(player.ppos, cposCapsule, platform.point1.cpos, platform.point2.cpos, intersectionPoint);\n\n    if (intersected && projectedResult.similarity < 0) {\n      // Do our best to prevent tunneling: rewind by the distance from the cpos\n      // capsule to the segment intersection point. `Translate` adds, so we have\n      // to sub intersectionPoint - capsule, which is slightly counterintuitive.\n      const offset = v2();\n      sub(offset,intersectionPoint, cposCapsule);\n      translate(offset, player.cpos, player.ppos);\n\n      const vout1 = v2();\n      const vout2 = v2();\n\n      // 1: nearly perfectly elastic (we still lose some energy due to gravity)\n      // 0: dead\n      const restitution = 1;\n\n      collisionResponseAABB(\n        player.cpos,\n        player.ppos,\n        player.mass,\n        restitution,\n        0.9,\n        0.1,\n        projectedResult.projectedPoint,\n        projectedResult.projectedPoint,\n        (platform.point1.mass + platform.point2.mass) * projectedResult.u,\n        restitution,\n        0.9,\n        0.1,\n        projectedResult.edgeNormal,\n        vout1,\n        vout2\n      );\n\n      sub(player.ppos, player.cpos, vout1);\n      // preserve systemic energy by giving the velocity that would have been\n      // imparted to the edge (if it were moveable) to the ball instead.\n      add(player.ppos, player.ppos, vout2);\n    }\n\n    for (let i = 0; i < circles.length; i++) {\n      const box = circles[i];\n      inertia(box);\n    }\n\n    for (let i = 0; i < 5; i++) {\n      // Not really necessary since we're never imparting velocity to the\n      // platform, but could be useful to demonstrate how to keep the shape if\n      // we did.\n      solveDistanceConstraint(\n        platform.point1,\n        platform.point1.mass,\n        platform.point2,\n        platform.point2.mass,\n        platform.goal\n      );\n    }\n\n    render(circles, [platform], ctx);\n    if (!running) return;\n    window.requestAnimationFrame(step);\n  })();\n\n  function render(\n    circles: CollidableCircle[],\n    segments: CollidableLine[],\n    ctx: CanvasRenderingContext2D\n  ) {\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n    for (let i = 0; i < circles.length; i++) {\n      const point = circles[i];\n\n      ctx.fillStyle = \"red\";\n      ctx.beginPath();\n      ctx.arc(point.ppos.x, point.ppos.y, point.radius, 0, Math.PI * 2, false);\n      ctx.fill();\n\n      ctx.fillStyle = \"black\";\n      ctx.beginPath();\n      ctx.arc(point.cpos.x, point.cpos.y, point.radius, 0, Math.PI * 2, false);\n      ctx.fill();\n    }\n\n    for (let i = 0; i < segments.length; i++) {\n      const segment = segments[i];\n      ctx.strokeStyle = \"red\";\n      ctx.beginPath();\n      ctx.moveTo(segment.point1.ppos.x, segment.point1.ppos.y);\n      ctx.lineTo(segment.point2.ppos.x, segment.point2.ppos.y);\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.strokeStyle = \"black\";\n      ctx.moveTo(segment.point1.cpos.x, segment.point1.cpos.y);\n      ctx.lineTo(segment.point2.cpos.x, segment.point2.cpos.y);\n      ctx.stroke();\n    }\n  }\n};\n","import * as AABBOverlapDemo from \"./aabb-overlap\";\nimport * as AABBSoupDemo from \"./aabb-soup\";\nimport * as CircleCollisions from \"./circle-collisions\";\nimport * as CircleBoxCollision from \"./circle-box-collision\";\nimport * as EdgeCollision from \"./edge-collision\";\nimport * as Platformer from \"./platformer\";\nimport * as Bucket from \"./bucket\";\nimport * as EdgeCollisionAABB from './edge-collision-aabb';\n\nconst qs = new URLSearchParams(window.location.search);\nconst demoName = qs.get(\"demo\");\n\nconst demos = new Map<string, { start: () => void; stop?: () => void }>([\n  [\"Bucket of Circles (Verlet)\", Bucket],\n  [\"Circle Collisions (Verlet)\", CircleCollisions],\n  [\"Circle to Box Collision (Verlet)\", CircleBoxCollision],\n  [\"Single Edge Circle Collision (Verlet)\", EdgeCollision],\n  [\"Platformer (AABB Impulse Model)\", Platformer],\n  [\"AABB Overlap Demo (AABB Impulse Model)\", AABBOverlapDemo],\n  [\"AABB Soup Demo (AABB Impulse Model)\", AABBSoupDemo],\n  [\"Single Edge Circle Collision (AABB Impulse Model)\", EdgeCollisionAABB]\n]);\n\nif (demoName && demos.has(demoName)) {\n  demos.get(demoName)!.start();\n} else {\n  const names = Array.from(demos.keys());\n\n  const li = (name: string) => {\n    const cmp = encodeURIComponent(name);\n    const url = `${window.location.pathname}?demo=${cmp}`;\n    return `\n      <li><a href=\"${url}\">${name}</a></li>\n    `;\n  };\n\n  const html = `\n    <ul>\n      ${names.map(name => li(name)).join(\"\\n\")}\n    </ul>\n  `;\n  const el = document.createElement(\"div\");\n  el.innerHTML = html;\n  document.body.appendChild(el);\n}\n"],"names":["$7e6fe066a466a13a$export$2c174af677a83e5f","x","y","$71fde6eb52f43e94$exports","onhalt","opt_msg","opt_keycode","document","addEventListener","e","which","console","log","$7e6fe066a466a13a$export$e214a2731b80666a","out","a","$7e6fe066a466a13a$export$77f8d2fc923b14e3","$7e6fe066a466a13a$export$568ed88074851180","b","$7e6fe066a466a13a$export$586fe8c46c9c97fc","$7e6fe066a466a13a$export$4cfcc6050dba3cbd","$7e6fe066a466a13a$export$8f869025bba9609b","factor","$7e6fe066a466a13a$export$d4cadb6bf5b49eb","v1","v2","Math","sqrt","$7e6fe066a466a13a$export$9f5b96d38bd327b4","$7e6fe066a466a13a$export$2e33abec8aecd572","len","$7e6fe066a466a13a$export$41b0d7466cde8385","by","vN","i","length","v","$e847b09a81a92581$export$6a2f0d61d3c528f1","cmp","dt","cpos","acel","$9508ee8874d310e3$var$vel1","$9508ee8874d310e3$var$vel2","$9508ee8874d310e3$var$diff","$9508ee8874d310e3$var$move","$9508ee8874d310e3$export$b8e7d7f5c7c785d8","p1","p1radius","p1mass","p2","p2radius","p2mass","preserveInertia","damping","dist2","$7e6fe066a466a13a$export$28d99b89327cb8ba","target","ppos","dist","mass1","mass2","massT","f1","f2","$d8eaf3d10fc1d98f$var$edgeDir","$d8eaf3d10fc1d98f$var$edge","$d8eaf3d10fc1d98f$var$hypo","$d8eaf3d10fc1d98f$var$collisionPoint","$d8eaf3d10fc1d98f$export$282dd05a97f3979c","circle","radius3","mass3","endpoint1","endpoint2","projection","maxDot","edgeMag","t","u","standinMass1","standinMass2","standin1","standin2","standin1Before","standin2Before","standin1Delta","standin2Delta","$61be21fdf37ead01$var$basis","$61be21fdf37ead01$var$basisNeg","$61be21fdf37ead01$var$vel1","$61be21fdf37ead01$var$vel1x","$61be21fdf37ead01$var$vel1y","$61be21fdf37ead01$var$vel2","$61be21fdf37ead01$var$vel2x","$61be21fdf37ead01$var$vel2y","$61be21fdf37ead01$var$newVel1","$61be21fdf37ead01$var$newVel2","$61be21fdf37ead01$var$t1","$61be21fdf37ead01$var$t2","$61be21fdf37ead01$var$u1","$61be21fdf37ead01$var$u2","$61be21fdf37ead01$export$1446d6ce9378f340","cpos1","ppos1","restitution1","staticFriction1","dynamicFriction1","cpos2","ppos2","restitution2","staticFriction2","dynamicFriction2","collisionNormal","vel1out","vel2out","massTotal","x1","x2","rv","reg1","tangent","jt","jtMag","abs","vel1ymag","vel2ymag","frictionImpulse1","frictionImpulse2","$d8fa7d6adf729855$export$23ee9a1bb354b3a9","goal","stiffness","impartEnergy","imass1","imass2","imass","delta","deltaMag","p1correction","p2correction","$1cbccbb0d2889279$var$accel1","$1cbccbb0d2889279$export$127f9e2414c35e1f","gravityConstant","mag","diffx","diffy","$2e1d21e6bbf4256e$export$a097199967c809ba","$6c002c109f75eae9$export$e9537977db997215","center1X","center1Y","width1","height1","center2X","center2Y","width2","height2","result","dx","px","dy","py","resolve","hitPos","normal","sx","sy","$a596c9b9bfddf62b$export$17f72f4a8b220b6f","ax","ay","arad","bx","brad","rad","$cca1159d30f939e1$var$s1","$cca1159d30f939e1$var$s2","$cca1159d30f939e1$export$81d3c89fef862237","p0","p3","intersectionPoint","s","$56687c5f7d4ddec2$var$tunnelPoint","$56687c5f7d4ddec2$var$offset","$56687c5f7d4ddec2$var$v","$56687c5f7d4ddec2$var$direction","$56687c5f7d4ddec2$var$radiusSegment","$56687c5f7d4ddec2$var$cposIncludingRadius","$56687c5f7d4ddec2$export$39dd994dd8eabb03","point3","point1","point2","$72cba1ff9435f606$export$d901e77cb1414629","distance","similarity","projectedPoint","edgeNormal","$72cba1ff9435f606$var$edgeDelta","$72cba1ff9435f606$var$perp","$72cba1ff9435f606$export$3754aa05e83ff6da","point","Error","proj","edgeNorm","$1df5fdced4fce664$var$v","$1df5fdced4fce664$var$direction","$1df5fdced4fce664$var$radiusSegment","$aad927c4bc26fd98$export$42328a91b0e9c643","cvs","createElement","ctx","getContext","width","height","style","border","body","appendChild","box1","w","h","mass","box2","points","collision","push","running","render","points1","ctx1","clearRect","canvas","fillStyle","fillRect","$parcel$interopDefault","step","overlapHalf","box1v","box2v","restitution","staticFriction","dynamicFriction","i1","window","requestAnimationFrame","$8489225dcd092268$export$42328a91b0e9c643","count","centerX","centerY","min","cos","sin","makeBox","GRAVITATIONAL_POINT","id","floor","random","i2","handled","i3","j","indexOf","i4","$99c3221f9d091edd$export$42328a91b0e9c643","CENTER","radius","center","baseRadius","num","all","max","generatePoints","colliding","unshift","ticks","pairs","pointA","pointB","collisionPairs","beginPath","arc","PI","fill","$9a41cd4a100a9991$export$42328a91b0e9c643","circles","lines","constraints","box","lines1","circles1","constraints1","prev","collideCircles","collideEdges","line","constraint","segments","segment","strokeStyle","moveTo","lineTo","stroke","$537a6ab66250b4b3$export$42328a91b0e9c643","tabIndex","player","platform","$469a6ffdad72da19$export$42328a91b0e9c643","Number","MAX_SAFE_INTEGER","boxes","keys","boxes1","key","preventDefault","isOverlapping","negativeResolve","ArrowLeft","ArrowRight","PLAYER_HOR_ACEL","ArrowUp","$161dfb793a7a43d1$export$42328a91b0e9c643","bucket","makeStaticMesh","midLine","pop","spawnRadius","makeCircles","makePolygon","forEach","poly","clines","gon","undefined","find","c","lineIsBounds","j1","i5","i6","i7","offset","$3e6c2ffd5e9e2eeb$export$42328a91b0e9c643","projectedResult","cposCapsule","p","vout1","vout2","$390d5b63d57edfe9$var$demoName","URLSearchParams","location","search","get","$390d5b63d57edfe9$var$demos","Map","$161dfb793a7a43d1$exports","$99c3221f9d091edd$exports","$9a41cd4a100a9991$exports","$537a6ab66250b4b3$exports","$469a6ffdad72da19$exports","$aad927c4bc26fd98$exports","$8489225dcd092268$exports","$3e6c2ffd5e9e2eeb$exports","has","start","names","Array","from","li","name","encodeURIComponent","pathname","html","map","join","el","innerHTML"],"version":3,"file":"index.e25e6626.js.map"}